<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hailan Blog</title>
  
  
  <link href="https://guohailan.github.io/atom.xml" rel="self"/>
  
  <link href="https://guohailan.github.io/"/>
  <updated>2021-01-18T15:17:44.479Z</updated>
  <id>https://guohailan.github.io/</id>
  
  <author>
    <name>Guo Hailan</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Trojan搭建</title>
    <link href="https://guohailan.github.io/2021/01/17/Trojan%E6%90%AD%E5%BB%BA/"/>
    <id>https://guohailan.github.io/2021/01/17/Trojan%E6%90%AD%E5%BB%BA/</id>
    <published>2021-01-17T10:25:13.000Z</published>
    <updated>2021-01-18T15:17:44.479Z</updated>
    
    <content type="html"><![CDATA[<p>使用trojan原版进行搭建。</p><a id="more"></a><h2 id="什么是Trojan"><a href="#什么是Trojan" class="headerlink" title="什么是Trojan"></a>什么是Trojan</h2><p>Trojan 是一个比较新的翻墙软件，它模仿了互联网上最常见的HTTPS协议，以诱骗 GFW 认为它就是 HTTPS，从而不被识别。所谓魔高一尺道高一丈，墙在不断往上砌，那工具也得跟着变了。Trojan 工作在 443 端口，并且处理来自外界的 HTTPS 请求，如果是合法的 Trojan 请求，那么为该请求提供服务，否则将该流量转交给 WEB 服务器 Nginx，由 Nginx 为其提供服务。基于这个工作过程可以知道，Trojan 的一切表现均与 Nginx 一致，不会引入额外特征，从而达到无法识别的效果。当然，为了防止恶意探测，我们需要将 80 端口的流量全部重定向到 443 端口，并且服务器只暴露 80 和 443 端口，这样可以使得服务器与常见的 WEB 服务器表现一致。</p><h2 id="域名准备"><a href="#域名准备" class="headerlink" title="域名准备"></a>域名准备</h2><p>域名申请可以去腾讯云或者阿里云等国内大厂申请（缺点就是需要花钱），这里我是去的免费域名商freenom申请的<a href="http://www.freenom.com/zh/index.html">http://www.freenom.com/zh/index.html</a>，不过访问这个地址很慢，所以可能需要提前出去。</p><h3 id="域名申请"><a href="#域名申请" class="headerlink" title="域名申请"></a>域名申请</h3><p>首先注册账号，基本信息里实测国家选择<font color="#DC143C">美国</font>以外的地区可能无法注册成功，所以这里我选择的洛杉矶</p><p><img src="/2021/01/17/Trojan%E6%90%AD%E5%BB%BA/myblog\source_posts\Trojan搭建\image-20210118221317622.png" alt="image-20210118221317622"></p><p>输入希望申请的域名，点击检查可用性</p><p><img src="/2021/01/17/Trojan%E6%90%AD%E5%BB%BA/myblog\source_posts\Trojan搭建\image-20210118220651867.png" alt="image-20210118220651867"></p><p>选择心仪的域名后缀，点击现在获取</p><p><img src="/2021/01/17/Trojan%E6%90%AD%E5%BB%BA/myblog\source_posts\Trojan搭建\image-20210118220757391.png" alt="image-20210118220757391"></p><p>域名时长我们一般选择最长时间1年，然后将VPS的IP填入解析地址（也可以现在不填，申请完成后在My Domains里面进行填写）</p><p><img src="/2021/01/17/Trojan%E6%90%AD%E5%BB%BA/myblog\source_posts\Trojan搭建\image-20210118222157926.png" alt="image-20210118222157926"></p><h3 id="域名测试"><a href="#域名测试" class="headerlink" title="域名测试"></a>域名测试</h3><p>默认的DNS生效时间比较长，大概半小时左右。本地能ping通域名，返回的地址为希望的IP，表示域名申请成功</p><p><img src="/2021/01/17/Trojan%E6%90%AD%E5%BB%BA/myblog\source_posts\Trojan搭建\image-20210118222954624.png" alt="image-20210118222954624"></p><h2 id="证书申请"><a href="#证书申请" class="headerlink" title="证书申请"></a>证书申请</h2><p>证书申请也是本着不花钱的原则，选择<a href="https://freessl.cn/">https://freessl.cn/</a></p><p>因为只有亚洲诚信可以支持双域名，而且有效期可以1年，所以选择亚洲诚信，点击创建免费的SSL证书</p><p><img src="/2021/01/17/Trojan%E6%90%AD%E5%BB%BA/myblog\source_posts\Trojan搭建\image-20210118223321305.png" alt="image-20210118223321305"></p><p>填入个人邮箱，然后点击创建</p><p><img src="/2021/01/17/Trojan%E6%90%AD%E5%BB%BA/myblog\source_posts\Trojan搭建\image-20210118223513080.png" alt="image-20210118223513080"></p><p>登录FreeSSL的账号，安装亚洲诚信的KeyManager</p><p><img src="/2021/01/17/Trojan%E6%90%AD%E5%BB%BA/myblog\source_posts\Trojan搭建\image-20210118223709924.png" alt="image-20210118223709924"></p><p>点击继续后，会自动带起KeyManager，生成秘钥</p><p><img src="/2021/01/17/Trojan%E6%90%AD%E5%BB%BA/myblog\source_posts\Trojan搭建\image-20210118223957243.png" alt="image-20210118223957243"></p><p>回到浏览器，在浏览器上会提示DNS验证</p><p><img src="/2021/01/17/Trojan%E6%90%AD%E5%BB%BA/myblog\source_posts\Trojan搭建\image-20210118224709956.png" alt="image-20210118224709956"></p><p>这时我们回到freenom点击My Domains，点击Manage Domain，选择Manage Freenom DNS</p><p><img src="/2021/01/17/Trojan%E6%90%AD%E5%BB%BA/myblog\source_posts\Trojan搭建\image-20210118224205751.png" alt="image-20210118224205751"></p><p>将证书生成的信息填入DNS的解析里面，Type选择TXT，然后点击保存</p><p><img src="/2021/01/17/Trojan%E6%90%AD%E5%BB%BA/myblog\source_posts\Trojan搭建\image-20210118224559935.png" alt="image-20210118224559935"></p><p>回到freessl页面，点击配置完成（可能有30分钟左右延迟），检测一下，当检测通过，点击验证即可签发证书，证书签发以后，可以使用https访问一下自己的域名，可以看到证书是有效的</p><p><img src="/2021/01/17/Trojan%E6%90%AD%E5%BB%BA/myblog\source_posts\Trojan搭建\image-20210118230001432.png" alt="image-20210118230001432"></p><h2 id="Torjan搭建"><a href="#Torjan搭建" class="headerlink" title="Torjan搭建"></a>Torjan搭建</h2><p><strong>此处我使用的是Centos7的系统</strong></p><p>首先安装依赖包</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum update -y &amp;&amp; yum install sudo newt curl -y &amp;&amp; sudo -i</span><br></pre></td></tr></table></figure><h3 id="安装BBR加速"><a href="#安装BBR加速" class="headerlink" title="安装BBR加速"></a>安装BBR加速</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget -N --no-check-certificate &quot;https://raw.githubusercontent.com/chiakge/Linux-NetSpeed/master/tcp.sh&quot; &amp;&amp; chmod +x tcp.sh &amp;&amp; ./tcp.sh</span><br></pre></td></tr></table></figure><p>选择需要的BBR加速内核，我的服务器默认已经安装了BBR内核，因此我直接选择4开启</p><p><img src="/2021/01/17/Trojan%E6%90%AD%E5%BB%BA/myblog\source_posts\Trojan搭建\image-20210118225435649.png" alt="image-20210118225435649"></p><h3 id="安装Trojan"><a href="#安装Trojan" class="headerlink" title="安装Trojan"></a>安装Trojan</h3><p>下载一键安装脚本</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -O https://raw.githubusercontent.com/atrandys/trojan/master/trojan_mult.sh &amp;&amp; chmod +x trojan_mult.sh &amp;&amp; ./trojan_mult.sh</span><br></pre></td></tr></table></figure><p>根据提示信息填入域名和密码即可搭建完成，搭建完成后访问域名会出现一个网站</p><p><img src="/2021/01/17/Trojan%E6%90%AD%E5%BB%BA/myblog\source_posts\Trojan搭建\image-20210118225825028.png" alt="image-20210118225825028"></p><h2 id="windows配置"><a href="#windows配置" class="headerlink" title="windows配置"></a>windows配置</h2><p>脚本执行完成后会在<code>/usr/src/trojan-cli/trojan-cli.zip</code>目录下生成带有配置文件的windows软件，下载到本地解压后双击<code>trojan.exe</code>直接运行即可，详细配置见<code>config.json</code></p><p><img src="/2021/01/17/Trojan%E6%90%AD%E5%BB%BA/myblog\source_posts\Trojan搭建\image-20210118230622791.png" alt="image-20210118230622791"></p><h4 id="安装v2rayN"><a href="#安装v2rayN" class="headerlink" title="安装v2rayN"></a>安装v2rayN</h4><p>到<a href="https://github.com/2dust/v2rayN/releases">https://github.com/2dust/v2rayN/releases</a>下载v2rayN客户端，此处下载的是稳定版</p><p><img src="/2021/01/17/Trojan%E6%90%AD%E5%BB%BA/myblog\source_posts\Trojan搭建\image-20210118231425080.png" alt="image-20210118231425080"></p><p>解压后运行软件，点击服务器，添加Socks服务器，填入地址如图</p><p><img src="/2021/01/17/Trojan%E6%90%AD%E5%BB%BA/myblog\source_posts\Trojan搭建\image-20210118231524385.png" alt="image-20210118231524385"></p><h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><p>访问google，能正常访问，在开启的Trojan和v2rayN都能看到访问的日志，搭建成功</p><p><img src="/2021/01/17/Trojan%E6%90%AD%E5%BB%BA/myblog\source_posts\Trojan搭建\image-20210118231650953.png" alt="image-20210118231650953"></p><h2 id="安卓配置"><a href="#安卓配置" class="headerlink" title="安卓配置"></a>安卓配置</h2><p>下载Trojan安卓客户端（一般选择*-universal-release.apk）<a href="https://github.com/trojan-gfw/igniter/releases">https://github.com/trojan-gfw/igniter/releases</a>，安装到手机即可</p><p><img src="/2021/01/17/Trojan%E6%90%AD%E5%BB%BA/myblog\source_posts\Trojan搭建\image-20210118231237972.png" alt="image-20210118231237972"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;使用trojan原版进行搭建。&lt;/p&gt;</summary>
    
    
    
    <category term="中间件" scheme="https://guohailan.github.io/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
    
    <category term="torjan" scheme="https://guohailan.github.io/tags/torjan/"/>
    
  </entry>
  
  <entry>
    <title>nginx配置限流</title>
    <link href="https://guohailan.github.io/2020/11/08/nginx%E9%85%8D%E7%BD%AE%E9%99%90%E6%B5%81/"/>
    <id>https://guohailan.github.io/2020/11/08/nginx%E9%85%8D%E7%BD%AE%E9%99%90%E6%B5%81/</id>
    <published>2020-11-08T09:20:37.000Z</published>
    <updated>2020-11-08T15:14:47.636Z</updated>
    
    <content type="html"><![CDATA[<p>系统设计时一般会预估负载，当系统暴露在公网中时，恶意攻击或正常突发流量等都可能导致系统被压垮，而限流就是保护措施之一。限流即控制流量，本文将记录 Nginx 的一种速率限流设置。</p><a id="more"></a><h2 id="ngx-http-limit-req-module"><a href="#ngx-http-limit-req-module" class="headerlink" title="ngx_http_limit_req_module"></a>ngx_http_limit_req_module</h2><p>ngx_http_limit_req_module模块提供限制请求处理速率能力，使用了漏桶算法(leaky bucket)，即能够强行保证请求的实时处理速度不会超过设置的阈值。<br><img src="/2020/11/08/nginx%E9%85%8D%E7%BD%AE%E9%99%90%E6%B5%81/%E9%99%90%E6%B5%81%E7%AE%97%E6%B3%95.png"><br>算法思想是：</p><ul><li>令牌以固定速率产生，并缓存到令牌桶中；</li><li>令牌桶放满时，多余的令牌被丢弃；</li><li>请求要消耗等比例的令牌才能被处理；</li><li>令牌不够时，请求被缓存。</li></ul><h3 id="配置示例"><a href="#配置示例" class="headerlink" title="配置示例"></a>配置示例</h3><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">http</span> &#123;</span><br><span class="line">    <span class="comment">#表示设置一块10m的共享内存来保存键值得状态，键为$uri，平均处理的频率不超过每秒1次</span></span><br><span class="line">    <span class="attribute">limit_req_zone</span> <span class="variable">$uri</span> zone=one:<span class="number">10m</span> rate=1r/s;</span><br><span class="line">    ...</span><br><span class="line">    <span class="section">server</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="attribute">location</span> /limittest &#123;</span><br><span class="line">            <span class="comment">#使用共享内存one，同时允许超过频率限制的请求数不多于5个,nodelay表示不希望超过的请求被延迟</span></span><br><span class="line">            <span class="attribute">limit_req</span> zone=one burst=<span class="number">5</span> nodelay;</span><br><span class="line">            <span class="comment">#如果超出限制，返回429的返回码</span></span><br><span class="line">            <span class="attribute">limit_req_status</span> <span class="number">429</span>;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h3 id="参数解析"><a href="#参数解析" class="headerlink" title="参数解析"></a>参数解析</h3><p>设置共享内存区域和请求的最大突发大小。如果请求速率超过为某个区域配置的速率，则它们的处理会延迟（不配置nodelay参数情况下），从而使请求按指定速率处理。过多的请求被延迟，直到它们的数量超过最大突发大小，在这种情况下请求被终止并出现错误。默认情况下，最大突发大小等于零。</p><p><code>limit_req_zone key zone=zone:size rate=rate;</code></p><p><strong>key</strong></p><ul><li>若客户的请求匹配了key，则进入zone。可以是文本、变量，通常为Nginx变量。如$binary_remote_addr(客户的ip)，$uri(不带参数的请求地址)，$request_uri(带参数的请求地址)，$server_name(服务器名称)。支持组合使用，使用空格隔开。</li></ul><p><strong>zone</strong></p><ul><li>使用zone=one，指定此zone的名字为one。</li></ul><p><strong>size</strong></p><ul><li>在zone=name后面紧跟:size，指定此zone的内存大小。如zone=name:10m，代表name的共享内存大小为10m。通常情况下，1m可以保存16000个状态。</li></ul><p><strong>rate</strong></p><ul><li>使用rate=1r/s，限制平均1秒不超过1个请求。使用rate=1r/m，限制平均1分钟不超过1个请求。如果需要每秒小于一个请求的速率，则按每分钟请求（r/m）指定。</li></ul><h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><p>编辑nginx配置文件<code>nginx.conf</code>,加入限流配置，<br>先执行<code>nginx -t</code>检查配置是否ok，如果返回success表示文件检查ok</p><p><img src="/2020/11/08/nginx%E9%85%8D%E7%BD%AE%E9%99%90%E6%B5%81/%E6%96%87%E4%BB%B6%E6%A3%80%E6%9F%A5.png"></p><p>然后执行<code>nginx -s reload</code>重启nginx，使配置生效<br>浏览器访问配置了限流的url进行验证，可以看到有429返回，表示限流配置生效<br><img src="/2020/11/08/nginx%E9%85%8D%E7%BD%AE%E9%99%90%E6%B5%81/%E9%99%90%E6%B5%81%E9%AA%8C%E8%AF%81.png"></p><h3 id="跳转自定义页面"><a href="#跳转自定义页面" class="headerlink" title="跳转自定义页面"></a>跳转自定义页面</h3><p>nginx触发限流后返回的页面非常不友好，因此我们可以开启自定义error页面，使返回页面更加友好</p><p>下面这段代码可以配置在server级别，也可以配置在location级别，为了不影响别的文根，此处我们在location下配置</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">location</span> /limittest &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment"># 关键参数：这个变量开启后，我们才能自定义错误页面，当后端返回429，nginx拦截错误定义错误页面</span></span><br><span class="line">    <span class="attribute">fastcgi_intercept_errors</span> <span class="literal">on</span>;</span><br><span class="line">    <span class="attribute">error_page</span>  <span class="number">429</span> /<span class="number">429</span>.html;</span><br><span class="line">    <span class="comment">#error_page 429 = http://www.test.com/429.html; 也可以重定向到另一个url</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>注意</code>:如果nginx返回的是本地的html，则页面状态码和定义的相同。若是跳转到某个url，页面状态码为302。</p><h2 id="nginx常见内置变量"><a href="#nginx常见内置变量" class="headerlink" title="nginx常见内置变量"></a>nginx常见内置变量</h2><ul><li>$args #这个变量等于请求行中的参数。</li><li>$content_length #请求头中的Content-length字段。</li><li>$content_type #请求头中的Content-Type字段。</li><li>$document_root #当前请求在root指令中指定的值。</li><li>$host #请求主机头字段，否则为服务器名称。</li><li>$http_user_agent #客户端agent信息</li><li>$http_cookie #客户端cookie信息</li><li>$limit_rate #这个变量可以限制连接速率。</li><li>$request_body_file #客户端请求主体信息的临时文件名。</li><li>$request_method #客户端请求的动作，通常为GET或POST。</li><li>$remote_addr #客户端的IP地址。</li><li>$remote_port #客户端的端口。</li><li>$remote_user #已经经过Auth Basic Module验证的用户名。</li><li>$request_filename #当前请求的文件路径，由root或alias指令与URI请求生成。</li><li>$query_string #与$args相同。</li><li>$scheme #HTTP方法（如http，https）。</li><li>$server_protocol #请求使用的协议，通常是HTTP/1.0或HTTP/1.1。</li><li>$server_addr #服务器地址，在完成一次系统调用后可以确定这个值。</li><li>$server_name #服务器名称。</li><li>$server_port #请求到达服务器的端口号。</li><li>$request_uri #包含请求参数的原始URI，不包含主机名，如：”/foo/bar.php?arg=baz”。</li><li>$uri #不带请求参数的当前URI，$uri不包含主机名，如”/foo/bar.html”。</li><li>$document_uri #与$uri相同。</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;系统设计时一般会预估负载，当系统暴露在公网中时，恶意攻击或正常突发流量等都可能导致系统被压垮，而限流就是保护措施之一。限流即控制流量，本文将记录 Nginx 的一种速率限流设置。&lt;/p&gt;</summary>
    
    
    
    <category term="中间件" scheme="https://guohailan.github.io/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
    <category term="nginx" scheme="https://guohailan.github.io/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/nginx/"/>
    
    
    <category term="nginx" scheme="https://guohailan.github.io/tags/nginx/"/>
    
    <category term="限流" scheme="https://guohailan.github.io/tags/%E9%99%90%E6%B5%81/"/>
    
  </entry>
  
  <entry>
    <title>goftp 125 Data connection already open问题</title>
    <link href="https://guohailan.github.io/2020/10/19/goftp-125-Data-connection-already-open%E9%97%AE%E9%A2%98/"/>
    <id>https://guohailan.github.io/2020/10/19/goftp-125-Data-connection-already-open%E9%97%AE%E9%A2%98/</id>
    <published>2020-10-19T13:24:51.000Z</published>
    <updated>2020-10-20T12:29:12.434Z</updated>
    
    <content type="html"><![CDATA[<p>记录一次使用goftp包文件上传异常的问题</p><a id="more"></a><h2 id="问题现象"><a href="#问题现象" class="headerlink" title="问题现象"></a>问题现象</h2><p>平常工作中，经常会涉及到ftp文件上传，所以使用第三方库github.com/dutchcoders/goftp，撸了个ftp上传脚本。之前使用都是正常上传，今天使用突然发现无法无法使用了，抛出的异常为<code>125 Data connection already open; transfer starting</code>，ftp服务器上文件名已经存在但是大小为0kb，因为编译成了exe格式，所以不涉及代码改动，顿时觉得比较奇怪，将代码又重新撸了一遍，未发现明显异常，报错依旧。</p><h2 id="定位过程"><a href="#定位过程" class="headerlink" title="定位过程"></a>定位过程</h2><p>在网上也没查到啥有用信息，只有一个ftp异常码的解释<code>125 Data connection already open; transfer starting.  资料连接已经打开，开始传送资料. </code>。后查阅ftp相关资料，ftp在文件上传的时候，是通过发送STOR命令来实现的，然后期待ftp返回150，是一个成功的响应码，后续会上传成功。但是现在只返回了一个125。查看goftp源码ftp.go，当ftp连接上以后，会返回一个状态，如果不是以<code>StatusFileOK</code>开头，则<code>return</code><br><img src="/2020/10/19/goftp-125-Data-connection-already-open%E9%97%AE%E9%A2%98/goftp_ftp.png">  </p><p>继续查看status.go中定义的<code>StatusFileOK</code>，定义的值为150，所以返回125会抛出异常。<br><img src="/2020/10/19/goftp-125-Data-connection-already-open%E9%97%AE%E9%A2%98/goftp_status.png"></p><h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><p>经过一下午的排查，原因找到了，应该是国庆期间公司对ftp的服务器进行了升级。IIS7对响应码处理做了调整。<a href="http://support.microsoft.com/kb/2505047">http://support.microsoft.com/kb/2505047</a> ，<font color="red">IIS7前，对APPE，STOU ，STOR命令，passive模式响应125，active模式响应150。IIS7.5后不考虑连接模式了，只考虑当前的连接状态，未连接响应150，已连接响应125</font>。</p><h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><p>使用了一个比较粗暴的办法，直接将源码status.go中的<code>StatusFileOK=&quot;150&quot;</code>改为<code>StatusFileOK=&quot;125&quot;</code>，重新编译脚本之后上传正常。因只在本地使用，未做兼容性测试。仅此记录</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;记录一次使用goftp包文件上传异常的问题&lt;/p&gt;</summary>
    
    
    
    <category term="编程语言" scheme="https://guohailan.github.io/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    <category term="Golang" scheme="https://guohailan.github.io/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Golang/"/>
    
    
    <category term="问题定位" scheme="https://guohailan.github.io/tags/%E9%97%AE%E9%A2%98%E5%AE%9A%E4%BD%8D/"/>
    
  </entry>
  
  <entry>
    <title>kubeadm搭建k8s 1.18</title>
    <link href="https://guohailan.github.io/2020/08/20/kubeadm%E6%90%AD%E5%BB%BAk8s-1-18/"/>
    <id>https://guohailan.github.io/2020/08/20/kubeadm%E6%90%AD%E5%BB%BAk8s-1-18/</id>
    <published>2020-08-20T12:58:38.000Z</published>
    <updated>2020-10-20T12:31:04.259Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要介绍k8s搭建，使用官方推荐工具kubeadm进行搭建，ETCD独立部署</p><a id="more"></a><h2 id="docker-安装"><a href="#docker-安装" class="headerlink" title="docker 安装"></a>docker 安装</h2><p>添加阿里镜像源地址</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</span><br></pre></td></tr></table></figure><p>安装docker出现如下错误,当前服务器上安装的containerd.io版本为1.2.0-3.el7版本过低</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[root@guohailan3 ~]<span class="comment"># yum -y install docker-ce</span></span><br><span class="line">上次元数据过期检查：0:00:07 前，执行于 2020年05月24日 星期日 03时42分48秒。</span><br><span class="line">错误：</span><br><span class="line"> 问题: package docker-ce-3:19.03.9-3.el7.x86_64 requires containerd.io &gt;= 1.2.2-3, but none of the providers can be installed</span><br><span class="line">  - cannot install the best candidate <span class="keyword">for</span> the job</span><br><span class="line">  - package containerd.io-1.2.10-3.2.el7.x86_64 is excluded</span><br><span class="line">  - package containerd.io-1.2.13-3.1.el7.x86_64 is excluded</span><br><span class="line">  - package containerd.io-1.2.13-3.2.el7.x86_64 is excluded</span><br><span class="line">  - package containerd.io-1.2.2-3.3.el7.x86_64 is excluded</span><br><span class="line">  - package containerd.io-1.2.2-3.el7.x86_64 is excluded</span><br><span class="line">  - package containerd.io-1.2.4-3.1.el7.x86_64 is excluded</span><br><span class="line">  - package containerd.io-1.2.5-3.1.el7.x86_64 is excluded</span><br><span class="line">  - package containerd.io-1.2.6-3.3.el7.x86_64 is excluded</span><br><span class="line">(尝试添加 <span class="string">&#x27;--skip-broken&#x27;</span> 来跳过无法安装的软件包 或 <span class="string">&#x27;--nobest&#x27;</span> 来不只使用最佳选择的软件包)</span><br></pre></td></tr></table></figure><p>升级containerd.io，再次进行安装</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wget https://download.docker.com/linux/centos/7/x86_64/edge/Packages/containerd.io-1.2.6-3.3.el7.x86_64.rpm</span><br><span class="line">yum install containerd.io-1.2.6-3.3.el7.x86_64.rpm</span><br></pre></td></tr></table></figure><p>配置开机启动和启动docker</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">systemctl <span class="built_in">enable</span> docker</span><br><span class="line">systemctl start docker</span><br></pre></td></tr></table></figure><p>优化docker参数</p><p><a href="https://kubernetes.io/zh/docs/setup/production-environment/container-runtimes/">官方文档</a>表示，更改设置，令容器运行时和kubelet使用systemd作为cgroup驱动，以此使系统更为稳定。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">tee /etc/docker/daemon.json &lt;&lt;-<span class="string">&#x27;EOF&#x27;</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;registry-mirrors&quot;</span>: [<span class="string">&quot;https://bk6kzfqm.mirror.aliyuncs.com&quot;</span>],</span><br><span class="line">  <span class="string">&quot;exec-opts&quot;</span>: [<span class="string">&quot;native.cgroupdriver=systemd&quot;</span>],</span><br><span class="line">  <span class="string">&quot;log-driver&quot;</span>: <span class="string">&quot;json-file&quot;</span>,</span><br><span class="line">  <span class="string">&quot;log-opts&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;max-size&quot;</span>: <span class="string">&quot;100m&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">&quot;storage-driver&quot;</span>: <span class="string">&quot;overlay2&quot;</span>,</span><br><span class="line">  <span class="string">&quot;storage-opts&quot;</span>: [</span><br><span class="line">    <span class="string">&quot;overlay2.override_kernel_check=true&quot;</span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br><span class="line">systemctl daemon-reload <span class="comment"># 重新加载</span></span><br><span class="line">systemctl restart docker <span class="comment"># 重启docker</span></span><br></pre></td></tr></table></figure><h2 id="kubernet-安装"><a href="#kubernet-安装" class="headerlink" title="kubernet 安装"></a>kubernet 安装</h2><h3 id="安装kubectl"><a href="#安装kubectl" class="headerlink" title="安装kubectl"></a>安装kubectl</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#无法连接google，配置了阿里的源</span></span><br><span class="line">cat &lt;&lt;<span class="string">EOF &gt; /etc/yum.repos.d/kubernetes.repo</span></span><br><span class="line"><span class="string">[kubernetes]</span></span><br><span class="line"><span class="string">name=Kubernetes</span></span><br><span class="line"><span class="string">baseurl=https://mirrors.aliyun.com/kubernetes/yum/repos/kubernetes-el7-x86_64/</span></span><br><span class="line"><span class="string">enabled=1</span></span><br><span class="line"><span class="string">gpgcheck=0</span></span><br><span class="line"><span class="string">EOF</span></span><br><span class="line">yum install -y kubectl</span><br><span class="line"></span><br><span class="line">setenforce 0 <span class="comment">#暂时关闭selinux</span></span><br><span class="line">sed -i <span class="string">&#x27;s/SELINUX=permissive/SELINUX=disabled/&#x27;</span> /etc/sysconfig/selinux <span class="comment">#Kubernetes 1.8开始要求关闭系统的Swap，如果不关闭，默认配置下kubelet将无法启动。</span></span><br><span class="line">swapoff -a</span><br><span class="line">yum install -y kubeadm kubelet <span class="comment">#安装kubeadm kubelet工具</span></span><br></pre></td></tr></table></figure><h3 id="准备证书"><a href="#准备证书" class="headerlink" title="准备证书"></a>准备证书</h3><p>证书需要在一台机器上生成，拷贝到别的机器上</p><h4 id="准备证书管理工具"><a href="#准备证书管理工具" class="headerlink" title="准备证书管理工具"></a>准备证书管理工具</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">wget https://pkg.cfssl.org/R1.2/cfssl_linux-amd64</span><br><span class="line">chmod +x cfssl_linux-amd64</span><br><span class="line">mv cfssl_linux-amd64 /usr/bin/cfssl</span><br><span class="line"></span><br><span class="line">wget https://pkg.cfssl.org/R1.2/cfssljson_linux-amd64</span><br><span class="line">chmod +x cfssljson_linux-amd64</span><br><span class="line">mv cfssljson_linux-amd64 /usr/bin/cfssljson</span><br><span class="line"></span><br><span class="line">wget https://pkg.cfssl.org/R1.2/cfssl-certinfo_linux-amd64</span><br><span class="line">chmod +x cfssl-certinfo_linux-amd64</span><br><span class="line">mv cfssl-certinfo_linux-amd64 /usr/bin/cfssl-certinfo</span><br></pre></td></tr></table></figure><h4 id="生成ETCD的TLS-秘钥和证书"><a href="#生成ETCD的TLS-秘钥和证书" class="headerlink" title="生成ETCD的TLS 秘钥和证书"></a>生成ETCD的TLS 秘钥和证书</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建 CA 配置文件</span></span><br><span class="line">mkdir ssl &amp;&amp; <span class="built_in">cd</span> ssl</span><br><span class="line">cfssl print-defaults csr &gt; csr.json</span><br><span class="line">cat &gt; config.json &lt;&lt;<span class="string">EOF</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">&quot;signing&quot;: &#123;</span></span><br><span class="line"><span class="string">    &quot;default&quot;: &#123;</span></span><br><span class="line"><span class="string">      &quot;expiry&quot;: &quot;8760h&quot;</span></span><br><span class="line"><span class="string">      &#125;,</span></span><br><span class="line"><span class="string">    &quot;profiles&quot;: &#123;</span></span><br><span class="line"><span class="string">      &quot;kubernetes&quot;: &#123;</span></span><br><span class="line"><span class="string">        &quot;usages&quot;: [</span></span><br><span class="line"><span class="string">            &quot;signing&quot;,</span></span><br><span class="line"><span class="string">            &quot;key encipherment&quot;,</span></span><br><span class="line"><span class="string">            &quot;server auth&quot;,</span></span><br><span class="line"><span class="string">            &quot;client auth&quot;</span></span><br><span class="line"><span class="string">        ],</span></span><br><span class="line"><span class="string">        &quot;expiry&quot;: &quot;8760h&quot;</span></span><br><span class="line"><span class="string">      &#125;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">EOF</span></span><br></pre></td></tr></table></figure><ul><li>config.json：可以定义多个 profiles，分别指定不同的过期时间、使用场景等参数；后续在签名证书时使用某个 profile；</li><li>signing：表示该证书可用于签名其它证书；生成的 ca.pem 证书中 CA=TRUE；</li><li>server auth：表示 client 可以用该 CA 对 server 提供的证书进行验证；</li><li>client auth：表示 server 可以用该 CA 对 client 提供的证书进行验证；</li></ul><h4 id="创建ca证书请求"><a href="#创建ca证书请求" class="headerlink" title="创建ca证书请求"></a>创建ca证书请求</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">cat &gt; ca-csr.json &lt;&lt;<span class="string">EOF</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">    &quot;CN&quot;: &quot;kubernetes&quot;,</span></span><br><span class="line"><span class="string">    &quot;key&quot;: &#123;</span></span><br><span class="line"><span class="string">        &quot;algo&quot;: &quot;rsa&quot;,</span></span><br><span class="line"><span class="string">        &quot;size&quot;: 2048</span></span><br><span class="line"><span class="string">    &#125;,</span></span><br><span class="line"><span class="string">    &quot;names&quot;: [</span></span><br><span class="line"><span class="string">        &#123;</span></span><br><span class="line"><span class="string">            &quot;C&quot;: &quot;CN&quot;,</span></span><br><span class="line"><span class="string">            &quot;L&quot;: &quot;GuangDong&quot;,</span></span><br><span class="line"><span class="string">            &quot;ST&quot;: &quot;ShenZhen&quot;,</span></span><br><span class="line"><span class="string">            &quot;O&quot;: &quot;k8s&quot;,</span></span><br><span class="line"><span class="string">            &quot;OU&quot;: &quot;System&quot;</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">    ]</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">EOF</span></span><br></pre></td></tr></table></figure><ul><li>“CN”：Common Name，kube-apiserver 从证书中提取该字段作为请求的用户名 (User Name)；浏览器使用该字段验证网站是否合法；</li><li>“O”：Organization，kube-apiserver 从证书中提取该字段作为请求用户所属的组 (Group)；</li></ul><h4 id="创建CA证书和私钥"><a href="#创建CA证书和私钥" class="headerlink" title="创建CA证书和私钥"></a>创建CA证书和私钥</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cfssl gencert -initca ca-csr.json | cfssljson -bare ca</span><br></pre></td></tr></table></figure><h4 id="创建-etcd-证书签名请求"><a href="#创建-etcd-证书签名请求" class="headerlink" title="创建 etcd 证书签名请求"></a>创建 etcd 证书签名请求</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">cat &gt; etcd-csr.json &lt;&lt;<span class="string">EOF</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">  &quot;CN&quot;: &quot;etcd&quot;,</span></span><br><span class="line"><span class="string">  &quot;hosts&quot;: [</span></span><br><span class="line"><span class="string">    &quot;192.168.31.48&quot;,</span></span><br><span class="line"><span class="string">    &quot;192.168.31.137&quot;,</span></span><br><span class="line"><span class="string">    &quot;192.168.31.226&quot;</span></span><br><span class="line"><span class="string">  ],</span></span><br><span class="line"><span class="string">  &quot;key&quot;: &#123;</span></span><br><span class="line"><span class="string">    &quot;algo&quot;: &quot;rsa&quot;,</span></span><br><span class="line"><span class="string">    &quot;size&quot;: 2048</span></span><br><span class="line"><span class="string">  &#125;,</span></span><br><span class="line"><span class="string">  &quot;names&quot;: [</span></span><br><span class="line"><span class="string">    &#123;</span></span><br><span class="line"><span class="string">      &quot;C&quot;: &quot;CN&quot;,</span></span><br><span class="line"><span class="string">      &quot;ST&quot;: &quot;GuangDong&quot;,</span></span><br><span class="line"><span class="string">      &quot;L&quot;: &quot;ShenZhen&quot;,</span></span><br><span class="line"><span class="string">      &quot;O&quot;: &quot;k8s&quot;,</span></span><br><span class="line"><span class="string">      &quot;OU&quot;: &quot;System&quot;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">  ]</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">EOF</span></span><br></pre></td></tr></table></figure><ul><li>hosts 字段指定授权使用该证书的 etcd 节点 IP；</li><li>每个节点IP 都要在里面 或者 每个机器申请一个对应IP的证书</li></ul><h4 id="生成-etcd-证书和私钥"><a href="#生成-etcd-证书和私钥" class="headerlink" title="生成 etcd 证书和私钥"></a>生成 etcd 证书和私钥</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cfssl gencert -ca=ca.pem \</span><br><span class="line">  -ca-key=ca-key.pem \</span><br><span class="line">  -config=config.json \</span><br><span class="line">  -profile=kubernetes etcd-csr.json | cfssljson -bare etcd</span><br></pre></td></tr></table></figure><h4 id="将证书拷贝到所有服务器的指定目录"><a href="#将证书拷贝到所有服务器的指定目录" class="headerlink" title="将证书拷贝到所有服务器的指定目录"></a>将证书拷贝到所有服务器的指定目录</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p /etc/etcd/ssl</span><br><span class="line">cp etcd.pem etcd-key.pem  ca.pem /etc/etcd/ssl/</span><br></pre></td></tr></table></figure><h3 id="安装ETCD"><a href="#安装ETCD" class="headerlink" title="安装ETCD"></a>安装ETCD</h3><h4 id="准备二进制文件"><a href="#准备二进制文件" class="headerlink" title="准备二进制文件"></a>准备二进制文件</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">wget https://github.com/coreos/etcd/releases/download/v3.4.9/etcd-v3.4.9-linux-amd64.tar.gz</span><br><span class="line">tar -vxf etcd-v3.4.9-linux-amd64.tar.gz</span><br><span class="line">cp etcd-v3.4.9-linux-amd64/etcd* /usr/bin/</span><br><span class="line">chmod +x /usr/bin/etcd*</span><br></pre></td></tr></table></figure><h4 id="部署环境变量"><a href="#部署环境变量" class="headerlink" title="部署环境变量"></a>部署环境变量</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> NODE_NAME=<span class="string">&quot;etcd-host1&quot;</span> <span class="comment">#当前部署的机器名称(随便定义，只要能区分不同机器即可)</span></span><br><span class="line"><span class="built_in">export</span> NODE_IP=<span class="string">&quot;192.168.31.48&quot;</span> <span class="comment"># 当前部署的机器 IP</span></span><br><span class="line"><span class="built_in">export</span> <span class="built_in">export</span> NODE_IPS=<span class="string">&quot;192.168.31.48 192.168.31.137 192.168.31.226&quot;</span> <span class="comment"># etcd 集群所有机器 IP</span></span><br><span class="line"><span class="comment"># etcd 集群间通信的IP和端口</span></span><br><span class="line"><span class="built_in">export</span> ETCD_NODES=<span class="string">&quot;etcd-host1=https://192.168.31.48:2380,etcd-host2=https://192.168.31.137:2380,etcd-host3=https://192.168.31.226:2380&quot;</span></span><br></pre></td></tr></table></figure><h4 id="创建etcd的systemd-unit文件"><a href="#创建etcd的systemd-unit文件" class="headerlink" title="创建etcd的systemd unit文件"></a>创建etcd的systemd unit文件</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p /var/lib/etcd  <span class="comment"># 必须先创建工作目录</span></span><br><span class="line">cat &gt; etcd.service &lt;&lt;<span class="string">EOF</span></span><br><span class="line"><span class="string">[Unit]</span></span><br><span class="line"><span class="string">Description=Etcd Server</span></span><br><span class="line"><span class="string">After=network.target</span></span><br><span class="line"><span class="string">After=network-online.target</span></span><br><span class="line"><span class="string">Wants=network-online.target</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">[Service]</span></span><br><span class="line"><span class="string">Type=notify</span></span><br><span class="line"><span class="string">WorkingDirectory=/var/lib/etcd/</span></span><br><span class="line"><span class="string">ExecStart=/usr/bin/etcd \\</span></span><br><span class="line"><span class="string">  --name=$&#123;NODE_NAME&#125; \\</span></span><br><span class="line"><span class="string">  --cert-file=/etc/etcd/ssl/etcd.pem \\</span></span><br><span class="line"><span class="string">  --key-file=/etc/etcd/ssl/etcd-key.pem \\</span></span><br><span class="line"><span class="string">  --peer-cert-file=/etc/etcd/ssl/etcd.pem \\</span></span><br><span class="line"><span class="string">  --peer-key-file=/etc/etcd/ssl/etcd-key.pem \\</span></span><br><span class="line"><span class="string">  --trusted-ca-file=/etc/etcd/ssl/ca.pem \\</span></span><br><span class="line"><span class="string">  --peer-trusted-ca-file=/etc/etcd/ssl/ca.pem \\</span></span><br><span class="line"><span class="string">  --initial-advertise-peer-urls=https://$&#123;NODE_IP&#125;:2380 \\</span></span><br><span class="line"><span class="string">  --listen-peer-urls=https://$&#123;NODE_IP&#125;:2380 \\</span></span><br><span class="line"><span class="string">  --listen-client-urls=https://$&#123;NODE_IP&#125;:2379,http://127.0.0.1:2379 \\</span></span><br><span class="line"><span class="string">  --advertise-client-urls=https://$&#123;NODE_IP&#125;:2379 \\</span></span><br><span class="line"><span class="string">  --initial-cluster-token=etcd-cluster-0 \\</span></span><br><span class="line"><span class="string">  --initial-cluster=$&#123;ETCD_NODES&#125; \\</span></span><br><span class="line"><span class="string">  --initial-cluster-state=new \\</span></span><br><span class="line"><span class="string">  --data-dir=/var/lib/etcd</span></span><br><span class="line"><span class="string">Restart=on-failure</span></span><br><span class="line"><span class="string">RestartSec=5</span></span><br><span class="line"><span class="string">LimitNOFILE=65536</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">[Install]</span></span><br><span class="line"><span class="string">WantedBy=multi-user.target</span></span><br><span class="line"><span class="string">EOF</span></span><br></pre></td></tr></table></figure><ul><li>–name：方便理解的节点名称，默认为 default，在集群中应该保持唯一，可以使用 hostname</li><li>–data-dir：服务运行数据保存的路径，默认为 ${name}.etcd</li><li>–snapshot-count：指定有多少事务（transaction）被提交时，触发截取快照保存到磁盘</li><li>–heartbeat-interval：leader 多久发送一次心跳到 followers。默认值是 100ms</li><li>–eletion-timeout：重新投票的超时时间，如果 follow 在该时间间隔没有收到心跳包，会触发重新投票，默认为 1000 ms</li><li>–listen-peer-urls：和同伴通信的地址，比如 <a href="http://ip:2380，如果有多个，使用逗号分隔。需要所有节点都能够访问，所以不要使用">http://ip:2380，如果有多个，使用逗号分隔。需要所有节点都能够访问，所以不要使用</a> localhost！</li><li>–listen-client-urls：对外提供服务的地址：比如 <a href="http://ip:2379,http://127.0.0.1:2379，客户端会连接到这里和">http://ip:2379,http://127.0.0.1:2379，客户端会连接到这里和</a> etcd 交互</li><li>–advertise-client-urls：对外公告的该节点客户端监听地址，这个值会告诉集群中其他节点</li><li>–initial-advertise-peer-urls：该节点同伴监听地址，这个值会告诉集群中其他节点</li><li>–initial-cluster：集群中所有节点的信息，格式为 node1=<a href="http://ip1:2380,node2=http://ip2:2380,…。注意：这里的">http://ip1:2380,node2=http://ip2:2380,…。注意：这里的</a> node1 是节点的 –name 指定的名字；后面的 ip1:2380 是 –initial-advertise-peer-urls 指定的值</li><li>–initial-cluster-state：新建集群的时候，这个值为 new；假如已经存在的集群，这个值为 existing</li><li>–initial-cluster-token：创建集群的 token，这个值每个集群保持唯一。这样的话，如果你要重新创建集群，即使配置和之前一样，也会再次生成新的集群和节点 uuid；否则会导致多个集群之间的冲突，造成未知的错误</li></ul><h4 id="启动-etcd-服务"><a href="#启动-etcd-服务" class="headerlink" title="启动 etcd 服务"></a>启动 etcd 服务</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mv etcd.service /etc/systemd/system/</span><br><span class="line">systemctl daemon-reload</span><br><span class="line">systemctl <span class="built_in">enable</span> etcd</span><br><span class="line">systemctl start etcd</span><br><span class="line">systemctl status etcd</span><br></pre></td></tr></table></figure><h4 id="验证服务并配置etcdctl工具"><a href="#验证服务并配置etcdctl工具" class="headerlink" title="验证服务并配置etcdctl工具"></a>验证服务并配置etcdctl工具</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">etcdctl --endpoints=<span class="string">&quot;https://192.168.31.48:2379,https://192.168.31.137:2379,https://192.168.31.226:2379&quot;</span> --cacert=/etc/etcd/ssl/ca.pem --cert=/etc/etcd/ssl/etcd.pem --key=/etc/etcd/ssl/etcd-key.pem endpoint health</span><br></pre></td></tr></table></figure><p>为了后续操作方便可配置alias</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">alias</span> etcdctl=<span class="string">&#x27;etcdctl --cacert=/etc/etcd/ssl/ca.pem --cert=/etc/etcd/ssl/etcd.pem --key=/etc/etcd/ssl/etcd-key.pem --endpoints=&quot;https://192.168.31.48:2379,https://192.168.31.137:2379,https://192.168.31.226:2379&quot;&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="初始化master"><a href="#初始化master" class="headerlink" title="初始化master"></a>初始化master</h3><h4 id="创建master配置文件"><a href="#创建master配置文件" class="headerlink" title="创建master配置文件"></a>创建master配置文件</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">cat &gt; /etc/kubernetes/config.yaml  &lt;&lt;<span class="string">EOF</span></span><br><span class="line"><span class="string">apiVersion: kubeadm.k8s.io/v1beta1</span></span><br><span class="line"><span class="string"># 国内不能访问 Google，修改为阿里云</span></span><br><span class="line"><span class="string">imageRepository: registry.aliyuncs.com/google_containers</span></span><br><span class="line"><span class="string">kind: ClusterConfiguration</span></span><br><span class="line"><span class="string">### etcd 配置及秘钥 ###</span></span><br><span class="line"><span class="string">etcd:</span></span><br><span class="line"><span class="string">  external:</span></span><br><span class="line"><span class="string">    endpoints:</span></span><br><span class="line"><span class="string">    - https://192.168.31.48:2379</span></span><br><span class="line"><span class="string">    - https://192.168.31.137:2379</span></span><br><span class="line"><span class="string">    - https://192.168.31.226:2379</span></span><br><span class="line"><span class="string">    caFile: /etc/etcd/ssl/ca.pem</span></span><br><span class="line"><span class="string">    certFile: /etc/etcd/ssl/etcd.pem</span></span><br><span class="line"><span class="string">    keyFile: /etc/etcd/ssl/etcd-key.pem</span></span><br><span class="line"><span class="string">    dataDir: /var/lib/etcd</span></span><br><span class="line"><span class="string">### calico 网络插件的子网 ###</span></span><br><span class="line"><span class="string">networking:</span></span><br><span class="line"><span class="string">  podSubnet: &quot;10.0.0.0/16&quot;</span></span><br><span class="line"><span class="string">  serviceSubnet: &quot;10.96.0.0/12&quot;</span></span><br><span class="line"><span class="string">###k8s的版本###</span></span><br><span class="line"><span class="string">kubernetesVersion: 1.18.0</span></span><br><span class="line"><span class="string">EOF</span></span><br></pre></td></tr></table></figure><h4 id="初始化master-1"><a href="#初始化master-1" class="headerlink" title="初始化master"></a>初始化master</h4><p>可查看依赖的镜像版本</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubeadm config images list --kubernetes-version=v1.18.0</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubeadm init --config /etc/kubernetes/config.yaml <span class="comment">#主节点进行初始化</span></span><br></pre></td></tr></table></figure><p>出现如下提示表示配置成功</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Your Kubernetes control-plane has initialized successfully!</span><br><span class="line"></span><br><span class="line">To start using your cluster, you need to run the following as a regular user:</span><br><span class="line">  mkdir -p <span class="variable">$HOME</span>/.kube</span><br><span class="line">  sudo cp -i /etc/kubernetes/admin.conf <span class="variable">$HOME</span>/.kube/config</span><br><span class="line">  sudo chown $(id -u):$(id -g) <span class="variable">$HOME</span>/.kube/config</span><br><span class="line"></span><br><span class="line">You should now deploy a pod network to the cluster.</span><br><span class="line">Run <span class="string">&quot;kubectl apply -f [podnetwork].yaml&quot;</span> with one of the options listed at:</span><br><span class="line">  https://kubernetes.io/docs/concepts/cluster-administration/addons/</span><br><span class="line"></span><br><span class="line">Then you can join any number of worker nodes by running the following on each as root:</span><br><span class="line">kubeadm join 192.168.31.226:6443 --token v7b8zo.5hc1au8vl96xqyie \</span><br><span class="line">    --discovery-token-ca-cert-hash sha256:908597386cd0311f24e2d7c95e40559e3137523078e69e1262643c6161abc10a</span><br></pre></td></tr></table></figure><p>如果出现如下错误，需要按照上图提示，配置kube/config</p><p><img src="/2020/08/20/kubeadm%E6%90%AD%E5%BB%BAk8s-1-18/image-20200815180231821.png" alt="image-20200815180231821"></p><h5 id="多master初始化"><a href="#多master初始化" class="headerlink" title="多master初始化"></a>多master初始化</h5><p>如果希望部署多master需要用下面的配置文件，token和tokenTTL在初始化第一台master的时候注释掉</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">cat &gt; /etc/kubernetes/config.yaml  &lt;&lt;<span class="string">EOF</span></span><br><span class="line"><span class="string">apiVersion: kubeadm.k8s.io/v1beta1</span></span><br><span class="line"><span class="string"># 国内不能访问 Google，修改为阿里云</span></span><br><span class="line"><span class="string">imageRepository: registry.aliyuncs.com/google_containers</span></span><br><span class="line"><span class="string">kind: ClusterConfiguration</span></span><br><span class="line"><span class="string">### etcd 配置及秘钥 ###</span></span><br><span class="line"><span class="string">etcd:</span></span><br><span class="line"><span class="string">  external:</span></span><br><span class="line"><span class="string">    endpoints:</span></span><br><span class="line"><span class="string">    - https://192.168.31.48:2379</span></span><br><span class="line"><span class="string">    - https://192.168.31.137:2379</span></span><br><span class="line"><span class="string">    - https://192.168.31.226:2379</span></span><br><span class="line"><span class="string">    caFile: /etc/etcd/ssl/ca.pem</span></span><br><span class="line"><span class="string">    certFile: /etc/etcd/ssl/etcd.pem</span></span><br><span class="line"><span class="string">    keyFile: /etc/etcd/ssl/etcd-key.pem</span></span><br><span class="line"><span class="string">    dataDir: /var/lib/etcd</span></span><br><span class="line"><span class="string">### calico 网络插件的子网 ###</span></span><br><span class="line"><span class="string">networking:</span></span><br><span class="line"><span class="string">  podSubnet: &quot;10.0.0.0/16&quot;</span></span><br><span class="line"><span class="string">  serviceSubnet: &quot;10.96.0.0/12&quot;</span></span><br><span class="line"><span class="string">###k8s的版本###</span></span><br><span class="line"><span class="string">kubernetesVersion: 1.18.0</span></span><br><span class="line"><span class="string">######多master配置#######</span></span><br><span class="line"><span class="string">#下面的token是master1节点初始化完成后，join得到的token值</span></span><br><span class="line"><span class="string">token: &quot;1gddb4.cs1chtdrk5r9aa0i&quot;</span></span><br><span class="line"><span class="string">tokenTTL: &quot;0s&quot;</span></span><br><span class="line"><span class="string">#是kubeadm帮我们apiserver生成对外服务的证书用的。因为外部访问apiserver是通过负载均衡实现的，所以作为服务端提供的证书中应该写的hosts是负载均衡的地址。</span></span><br><span class="line"><span class="string">apiServerCertSANs:</span></span><br><span class="line"><span class="string">#允许访问apiserver的地址</span></span><br><span class="line"><span class="string">- 192.168.30.189 #apiserver的负载均衡ip，或者是slb的ip</span></span><br><span class="line"><span class="string">- k8s-master1</span></span><br><span class="line"><span class="string">- k8s-slave1</span></span><br><span class="line"><span class="string">- k8s-slave2</span></span><br><span class="line"><span class="string">- 192.168.31.48</span></span><br><span class="line"><span class="string">- 192.168.31.137</span></span><br><span class="line"><span class="string">- 192.168.31.226</span></span><br><span class="line"><span class="string">apiServerExtraArgs:</span></span><br><span class="line"><span class="string"> apiserver-count: &quot;3&quot;</span></span><br><span class="line"><span class="string"> endpoint-reconciler-type: lease</span></span><br><span class="line"><span class="string">EOF</span></span><br></pre></td></tr></table></figure><h2 id="calico安装"><a href="#calico安装" class="headerlink" title="calico安装"></a>calico安装</h2><p>安装calico</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">kubectl apply -f https://docs.projectcalico.org/v3.15/manifests/calico.yaml</span><br><span class="line">https://docs.projectcalico.org/manifests/calico-etcd.yaml</span><br><span class="line">kubectl apply -f https://docs.projectcalico.org/manifests/calico.yaml</span><br></pre></td></tr></table></figure><p>查看节点启动详情，calico3个进程都启动完毕</p><p><img src="/2020/08/20/kubeadm%E6%90%AD%E5%BB%BAk8s-1-18/image-20200815183600446.png" alt="image-20200815183600446"></p><h2 id="添加node节点"><a href="#添加node节点" class="headerlink" title="添加node节点"></a>添加node节点</h2><p>在另一台节点执行下面命令，加入集群</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubeadm join 192.168.31.226:6443 --token v7b8zo.5hc1au8vl96xqyie     --discovery-token-ca-cert-hash sha256:908597386cd0311f24e2d7c95e40559e3137523078e69e1262643c6161abc10a</span><br></pre></td></tr></table></figure><p>出现如下提示表示加入成功</p><p><img src="/2020/08/20/kubeadm%E6%90%AD%E5%BB%BAk8s-1-18/image-20200815181858759.png" alt="image-20200815181858759"></p><p>在master执行<code>kubectl get nodes</code>，看到node状态都是Ready表示搭建完成</p><p><img src="/2020/08/20/kubeadm%E6%90%AD%E5%BB%BAk8s-1-18/image-20200815183942023.png" alt="image-20200815183942023"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文主要介绍k8s搭建，使用官方推荐工具kubeadm进行搭建，ETCD独立部署&lt;/p&gt;</summary>
    
    
    
    <category term="中间件" scheme="https://guohailan.github.io/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
    <category term="K8S" scheme="https://guohailan.github.io/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/K8S/"/>
    
    
    <category term="k8s" scheme="https://guohailan.github.io/tags/k8s/"/>
    
  </entry>
  
  <entry>
    <title>python分析豆瓣影评</title>
    <link href="https://guohailan.github.io/2020/07/05/python%E5%88%86%E6%9E%90%E8%B1%86%E7%93%A3%E5%BD%B1%E8%AF%84/"/>
    <id>https://guohailan.github.io/2020/07/05/python%E5%88%86%E6%9E%90%E8%B1%86%E7%93%A3%E5%BD%B1%E8%AF%84/</id>
    <published>2020-07-05T05:59:11.000Z</published>
    <updated>2020-10-20T12:31:31.239Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要对当前热门剧《隐秘的角落》进行豆瓣短评以及评价进行可视化分析，数据抓取主要为python编写的爬虫。</p><a id="more"></a><p>本文主要分为2个部分，分别对爬虫和可视化部分进行详解，本文脚本基于python 3.8.0版本进行编写</p><table><thead><tr><th>第三方依赖包</th><th>说明</th></tr></thead><tbody><tr><td>pyecharts</td><td>百度开源可视化工具，用于生成图表和词云</td></tr><tr><td>jieba</td><td>国内比较好用的分词工具</td></tr><tr><td>requests</td><td>python常用HTTP 库</td></tr><tr><td>lxml</td><td>pyhon常用XML和HTML解析库</td></tr></tbody></table><p><img src="/2020/07/05/python%E5%88%86%E6%9E%90%E8%B1%86%E7%93%A3%E5%BD%B1%E8%AF%84/score.png"></p><p><img src="/2020/07/05/python%E5%88%86%E6%9E%90%E8%B1%86%E7%93%A3%E5%BD%B1%E8%AF%84/short_comments.png"></p><h2 id="数据抓取"><a href="#数据抓取" class="headerlink" title="数据抓取"></a>数据抓取</h2><h3 id="日志打印"><a href="#日志打印" class="headerlink" title="日志打印"></a>日志打印</h3><p>为了方便调试和问题定位，单独引入了logging模块进行日志打印，为方便复用，日志部分单独写到了一个文件中，创建log.py文件</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"><span class="keyword">import</span> logging.handlers</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Logger</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    level_relations = &#123;</span><br><span class="line">        <span class="string">&#x27;debug&#x27;</span>:logging.DEBUG,</span><br><span class="line">        <span class="string">&#x27;info&#x27;</span>:logging.INFO,</span><br><span class="line">        <span class="string">&#x27;warning&#x27;</span>:logging.WARNING,</span><br><span class="line">        <span class="string">&#x27;error&#x27;</span>:logging.ERROR,</span><br><span class="line">        <span class="string">&#x27;crit&#x27;</span>:logging.CRITICAL</span><br><span class="line">    &#125;<span class="comment">#日志级别关系映射</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,filename,level=<span class="string">&#x27;info&#x27;</span>,when=<span class="string">&#x27;H&#x27;</span>,backCount=<span class="number">3</span>,fmt=<span class="string">&#x27;%(asctime)s - %(pathname)s[line:%(lineno)d] - %(levelname)s: %(message)s&#x27;</span></span>):</span></span><br><span class="line">        <span class="comment">#日志格式</span></span><br><span class="line">        <span class="comment">#----------------------------</span></span><br><span class="line">        <span class="comment"># %(asctime)s      年-月-日 时-分-秒，毫秒</span></span><br><span class="line">        <span class="comment"># %(filename)s     文件名，不含目录</span></span><br><span class="line">        <span class="comment"># %(pathname)s     目录名，完整路径</span></span><br><span class="line">        <span class="comment"># %(funcName)s     函数名</span></span><br><span class="line">        <span class="comment"># %(levelname)s    级别名</span></span><br><span class="line">        <span class="comment"># %(lineno)d       行号</span></span><br><span class="line">        <span class="comment"># %(module)s       模块名</span></span><br><span class="line">        <span class="comment"># %(message)s      日志信息</span></span><br><span class="line">        <span class="comment"># %(name)s         日志模块名</span></span><br><span class="line">        <span class="comment"># %(process)d      进程id</span></span><br><span class="line">        <span class="comment"># %(processName)s  进程名</span></span><br><span class="line">        <span class="comment"># %(thread)d       线程id</span></span><br><span class="line">        <span class="comment"># %(threadName)s   线程名</span></span><br><span class="line">        self.logger = logging.getLogger(filename)</span><br><span class="line">        format_str = logging.Formatter(fmt)<span class="comment">#设置日志格式</span></span><br><span class="line">        self.logger.setLevel(self.level_relations.get(level))<span class="comment">#设置日志级别</span></span><br><span class="line">        sh = logging.StreamHandler()<span class="comment">#往屏幕上输出</span></span><br><span class="line">        sh.setFormatter(format_str) <span class="comment">#设置屏幕上显示的格式</span></span><br><span class="line">        th = logging.handlers.TimedRotatingFileHandler(filename=filename,when=when,backupCount=backCount,encoding=<span class="string">&#x27;utf-8&#x27;</span>)<span class="comment">#往文件里写入#指定间隔时间自动生成文件的处理器</span></span><br><span class="line">        <span class="comment">#实例化TimedRotatingFileHandler</span></span><br><span class="line">        <span class="comment">#interval是时间间隔，backupCount是备份文件的个数，如果超过这个个数，就会自动删除，when是间隔的时间单位，单位有以下几种：</span></span><br><span class="line">        <span class="comment"># S 秒</span></span><br><span class="line">        <span class="comment"># M 分</span></span><br><span class="line">        <span class="comment"># H 小时、</span></span><br><span class="line">        <span class="comment"># D 天、</span></span><br><span class="line">        <span class="comment"># W 每星期（interval==0时代表星期一）</span></span><br><span class="line">        <span class="comment"># midnight 每天凌晨</span></span><br><span class="line">        th.setFormatter(format_str)<span class="comment">#设置文件里写入的格式</span></span><br><span class="line">        self.logger.addHandler(sh) <span class="comment">#把对象加到logger里</span></span><br><span class="line">        self.logger.addHandler(th)</span><br></pre></td></tr></table></figure><h3 id="爬虫"><a href="#爬虫" class="headerlink" title="爬虫"></a>爬虫</h3><p>豆瓣对未登陆账号的请求有些限制，短评只能看到前面200条，所以采取了登陆账号的方式来请求更多的数据。豆瓣返回的数据为xml，因此采用了xpath的方式来获取短评数据，然后将数据存入本地文本中</p><p><img src="/2020/07/05/python%E5%88%86%E6%9E%90%E8%B1%86%E7%93%A3%E5%BD%B1%E8%AF%84/xpath.png"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">sprider</span>():</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="comment"># 设置请求头</span></span><br><span class="line">        self.headers = &#123;<span class="string">&#x27;User-Agent&#x27;</span>: <span class="string">&#x27;Mozilla/5.0 (Windows NT 10.0; WOW64; Trident/7.0; rv:11.0) like Gecko&#x27;</span>&#125;</span><br><span class="line">        self.short_comments_file = sys.path[<span class="number">0</span>]+<span class="string">&quot;\\Short_comments_file.txt&quot;</span></span><br><span class="line">        self.score_file = sys.path[<span class="number">0</span>]+<span class="string">&quot;\\score_file.txt&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">login</span>(<span class="params">self,session</span>):</span></span><br><span class="line">        login_url = <span class="string">&#x27;https://accounts.douban.com/j/mobile/login/basic&#x27;</span></span><br><span class="line">        <span class="comment">## 账号和密码需要修改为正确的</span></span><br><span class="line">        postData = &#123;<span class="string">&#x27;ck&#x27;</span>: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">                    <span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;yourname&#x27;</span>,</span><br><span class="line">                    <span class="string">&#x27;password&#x27;</span>: <span class="string">&#x27;passwd&#x27;</span>,</span><br><span class="line">                    <span class="string">&#x27;remember&#x27;</span>: <span class="string">&#x27;false&#x27;</span>,</span><br><span class="line">                    <span class="string">&#x27;ticket&#x27;</span>: <span class="string">&#x27;&#x27;</span>&#125;</span><br><span class="line">        <span class="comment"># 从网上看到，需要先get请求一次才能成功，不然能登录能200，但是不能进行后续的get请求抛403，具体原因不详</span></span><br><span class="line">        a = session.get(login_url,headers=self.headers)</span><br><span class="line">        b = session.post(login_url, data=postData, headers=self.headers)</span><br><span class="line">        <span class="keyword">if</span> b.status_code == <span class="number">200</span>:</span><br><span class="line">            logger.logger.info(<span class="string">&quot;登录成功&quot;</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 登陆失败打印返回码和失败详情</span></span><br><span class="line">            logger.logger.error(<span class="string">&quot;登录失败:&quot;</span>+<span class="built_in">str</span>(b.status_code)+<span class="built_in">str</span>(b.text))</span><br><span class="line">            sys.exit(<span class="number">48</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_request</span>(<span class="params">self,url,session</span>):</span></span><br><span class="line">        <span class="comment"># get请求获取短评详情</span></span><br><span class="line">        request = session.get(url,headers=self.headers)</span><br><span class="line">        <span class="keyword">if</span> request.status_code == <span class="number">200</span>:</span><br><span class="line">            <span class="comment"># 防止乱码，将编码格式设置为utf-8</span></span><br><span class="line">            request.encode = <span class="string">&#x27;utf-8&#x27;</span></span><br><span class="line">            <span class="keyword">return</span> request.text</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            logger.logger.error(<span class="string">&#x27;current status_code:&#x27;</span>+<span class="built_in">str</span>(request.status_code)+<span class="built_in">str</span>(request.text))</span><br><span class="line">            sys.exit(<span class="number">44</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">xpath_analysis</span>(<span class="params">self, text, xpath</span>):</span></span><br><span class="line">        html = etree.HTML(text)</span><br><span class="line">        <span class="comment"># 使用xpath进行短评解析</span></span><br><span class="line">        result = html.xpath(xpath)</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">to_file</span>(<span class="params">self, filename, data</span>):</span></span><br><span class="line">        <span class="comment"># 采用追加的方式将内容写入文件</span></span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(filename, <span class="string">&#x27;a&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">            <span class="comment"># xpath获取的data为列表，所以用遍历的方式写入</span></span><br><span class="line">            logger.logger.info(data)</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> data:</span><br><span class="line">                f.write(i+<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">init_file</span>(<span class="params">self, filename</span>):</span></span><br><span class="line">        <span class="comment"># 初始化文件，直接清空</span></span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(filename, <span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">            f.write(<span class="string">&#x27;&#x27;</span>)</span><br></pre></td></tr></table></figure><h2 id="可视化"><a href="#可视化" class="headerlink" title="可视化"></a>可视化</h2><p>可视化部分主要是对前一步抓取到的数据进行清洗和分析，分词库用的是<a href="https://github.com/fxsjy/jieba">jieba</a>。图表生成使用的是百度开源可视化工具<a href="http://pyecharts.herokuapp.com/">pyecharts</a>，本文只用了柱状图和词云，更多高级用法见<a href="http://pyecharts.org/#/zh-cn/intro">pyecharts官方文档</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">visualization</span>():</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="comment"># 初始化文件路径</span></span><br><span class="line">        self.short_comments_file = sys.path[<span class="number">0</span>]+<span class="string">&quot;\\Short_comments_file.txt&quot;</span></span><br><span class="line">        self.score_file = sys.path[<span class="number">0</span>]+<span class="string">&quot;\\score_file.txt&quot;</span></span><br><span class="line">        self.path = sys.path[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">analysis_score</span>(<span class="params">self</span>):</span></span><br><span class="line">        evaluate = &#123;&#125;</span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(self.score_file, <span class="string">&#x27;r&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> f.readlines():</span><br><span class="line">                i = re.sub(<span class="string">r&quot;[A-Za-z0-9\-\:]&quot;</span>, <span class="string">&quot;&quot;</span>, i)</span><br><span class="line">                i = i.strip()  <span class="comment"># 去掉每行的换行符</span></span><br><span class="line">                <span class="comment"># 如果这个没出现过，就初始化为1</span></span><br><span class="line">                <span class="keyword">if</span> i <span class="keyword">not</span> <span class="keyword">in</span> evaluate:</span><br><span class="line">                    evaluate[i] = <span class="number">1</span></span><br><span class="line">                    logger.logger.debug(evaluate)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="comment"># 如果已经出现过了，就在自加1</span></span><br><span class="line">                    evaluate[i] += <span class="number">1</span></span><br><span class="line">                    logger.logger.debug(evaluate)</span><br><span class="line">            logger.logger.info(evaluate)</span><br><span class="line">        bar = Bar()</span><br><span class="line">        eva = []</span><br><span class="line">        count = []</span><br><span class="line">        <span class="keyword">for</span> k, v <span class="keyword">in</span> evaluate.items():</span><br><span class="line">            <span class="keyword">if</span> k != <span class="string">&#x27;&#x27;</span>:</span><br><span class="line">                eva.append(k)</span><br><span class="line">                count.append(v)</span><br><span class="line">        bar.add_xaxis(eva)  <span class="comment"># 柱状图x轴</span></span><br><span class="line">        logger.logger.info(<span class="string">&#x27;xaxis&#x27;</span>+<span class="built_in">str</span>(eva))</span><br><span class="line">        bar.add_yaxis(<span class="string">&quot;评价&quot;</span>, count)  <span class="comment"># 柱状图y轴</span></span><br><span class="line">        logger.logger.info(<span class="string">&#x27;yaxis&#x27;</span>+<span class="built_in">str</span>(count))</span><br><span class="line">        bar.set_global_opts(title_opts=opts.TitleOpts(title=<span class="string">&quot;隐秘的角落 豆瓣评分&quot;</span>))</span><br><span class="line">        <span class="comment"># 生成可视化图表</span></span><br><span class="line">        bar.render(self.path+<span class="string">&quot;\\score.html&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">analysis_short_comment</span>(<span class="params">self</span>):</span></span><br><span class="line">        cut_words = <span class="string">&quot;&quot;</span></span><br><span class="line">        <span class="keyword">for</span> line <span class="keyword">in</span> <span class="built_in">open</span>(self.short_comments_file, <span class="string">&#x27;r&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>):</span><br><span class="line">            line.strip(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">            <span class="comment"># 正则去掉标点等无效的字符，对数据进行清洗</span></span><br><span class="line">            line = re.sub(<span class="string">r&quot;[A-Za-z0-9\：\·\—\，\。\“ \”\....]&quot;</span>, <span class="string">&quot;&quot;</span>, line)</span><br><span class="line">            <span class="comment"># cut_all=False为精确模式，cut_all=True为全词模式</span></span><br><span class="line">            seg_list = jieba.cut(line, cut_all=<span class="literal">False</span>)</span><br><span class="line">            cut_words += (<span class="string">&quot; &quot;</span>.join(seg_list))</span><br><span class="line">        all_words = cut_words.split()</span><br><span class="line">        c = Counter()</span><br><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> all_words:</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(x) &gt; <span class="number">1</span> <span class="keyword">and</span> x != <span class="string">&#x27;\r\n&#x27;</span>:</span><br><span class="line">                c[x] += <span class="number">1</span></span><br><span class="line">        words = c.most_common(<span class="number">500</span>)  <span class="comment"># 输出词频最高的前500词</span></span><br><span class="line">        logger.logger.debug(words)</span><br><span class="line">        wordcloud = WordCloud()</span><br><span class="line">        wordcloud.add(<span class="string">&quot;&quot;</span>, words, word_size_range=[<span class="number">5</span>, <span class="number">100</span>], shape=<span class="string">&#x27;circle&#x27;</span>)</span><br><span class="line">        wordcloud.set_global_opts(title_opts=opts.TitleOpts(title=<span class="string">&quot;隐秘的角落 短评&quot;</span>))</span><br><span class="line">        wordcloud.render(self.path+<span class="string">&quot;\\short_comment.html&quot;</span>)</span><br></pre></td></tr></table></figure><h2 id="主函数"><a href="#主函数" class="headerlink" title="主函数"></a>主函数</h2><p>为了防止被豆瓣封IP，降低了采集频率采取了单线程和每次请求随机sleep 0.1s-4s的方式</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run_sprider</span>(<span class="params">sprider</span>):</span></span><br><span class="line">    <span class="comment"># 初始化文件</span></span><br><span class="line">    sprider.init_file(sprider.short_comments_file)</span><br><span class="line">    sprider.init_file(sprider.score_file)</span><br><span class="line">    <span class="comment"># 遍历获取数据</span></span><br><span class="line">    s = requests.session()</span><br><span class="line">    sprider.login(s)</span><br><span class="line">    <span class="keyword">for</span> page_start <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="number">500</span>, <span class="number">20</span>):  <span class="comment"># 范围从0-500，步长为20,页面上总评论数为500+</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            delay = <span class="built_in">round</span>(random.uniform(<span class="number">0.1</span>, <span class="number">4</span>), <span class="number">1</span>)</span><br><span class="line">            logger.logger.info(<span class="string">&#x27;i will sleep:&#x27;</span>+<span class="built_in">str</span>(delay)+<span class="string">&#x27;s&#x27;</span>)</span><br><span class="line">            time.sleep(delay)</span><br><span class="line">            URL = <span class="string">&#x27;https://movie.douban.com/subject/33404425/comments?start=&#123;&#125;&amp;limit=20&amp;sort=new_score&amp;status=P&#x27;</span>.<span class="built_in">format</span>(</span><br><span class="line">                page_start)</span><br><span class="line">            logger.logger.info(<span class="string">&#x27;current_request_url:&#x27;</span>+URL)</span><br><span class="line">            x = sprider.get_request(URL,s)</span><br><span class="line">            <span class="comment"># 短评的xpath路径</span></span><br><span class="line">            xpath = <span class="string">&#x27;//*[@id=&quot;comments&quot;]/div[*]/div[2]/p/span/text()&#x27;</span></span><br><span class="line">            short_comment = sprider.xpath_analysis(x, xpath)</span><br><span class="line">            sprider.to_file(sprider.short_comments_file, short_comment)</span><br><span class="line">            <span class="comment"># 评分的xpath路径</span></span><br><span class="line">            xpath2 = <span class="string">&#x27;//*[@id=&quot;comments&quot;]/div[*]/div[2]/h3/span[2]/span[2]/@title&#x27;</span></span><br><span class="line">            score = sprider.xpath_analysis(x, xpath2)</span><br><span class="line">            sprider.to_file(sprider.score_file, score)</span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">            logger.logger.error(e)</span><br><span class="line">            logger.logger.info(<span class="string">&#x27;current_page:&#x27;</span>+page_start)</span><br><span class="line">            sys.exit(<span class="number">146</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="comment"># 数据抓取</span></span><br><span class="line">    sprider = sprider()</span><br><span class="line">    run_sprider(sprider)</span><br><span class="line">    <span class="comment"># 数据分析和图标生成</span></span><br><span class="line">    c = visualization()</span><br><span class="line">    c.analysis_score()</span><br><span class="line">    c.analysis_short_comment()</span><br></pre></td></tr></table></figure><h2 id="完整源码"><a href="#完整源码" class="headerlink" title="完整源码"></a>完整源码</h2><p><a href="log.py">log.py</a><br><a href="sprider.py">sprider.py</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文主要对当前热门剧《隐秘的角落》进行豆瓣短评以及评价进行可视化分析，数据抓取主要为python编写的爬虫。&lt;/p&gt;</summary>
    
    
    
    <category term="编程语言" scheme="https://guohailan.github.io/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    <category term="Python" scheme="https://guohailan.github.io/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Python/"/>
    
    
    <category term="可视化" scheme="https://guohailan.github.io/tags/%E5%8F%AF%E8%A7%86%E5%8C%96/"/>
    
    <category term="爬虫" scheme="https://guohailan.github.io/tags/%E7%88%AC%E8%99%AB/"/>
    
  </entry>
  
  <entry>
    <title>Redis集群搭建</title>
    <link href="https://guohailan.github.io/2020/06/18/Redis%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/"/>
    <id>https://guohailan.github.io/2020/06/18/Redis%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/</id>
    <published>2020-06-18T14:15:07.000Z</published>
    <updated>2020-10-20T12:31:42.566Z</updated>
    
    <content type="html"><![CDATA[<p>Redis3.0上加入了cluster模式，实现的redis的分布式存储，本文主要介绍Redis集群的相关搭建。</p><a id="more"></a><h2 id="集群特点"><a href="#集群特点" class="headerlink" title="集群特点"></a>集群特点</h2><p>redis的哨兵模式基本已经可以实现高可用，读写分离 ，但是在这种模式下每台redis服务器都存储相同的数据，很浪费内存，所以在redis3.0上加入了cluster模式，实现的redis的分布式存储，也就是说每台redis节点上存储不同的内容。</p><p> Redis-Cluster采用无中心结构,它的特点如下：</p><ul><li>所有的redis节点彼此互联(PING-PONG机制),内部使用二进制协议优化传输速度和带宽。</li><li>节点的fail是通过集群中超过半数的节点检测失效时才生效。</li><li>客户端与redis节点直连,不需要中间代理层.客户端不需要连接集群所有节点,连接集群中任何一个可用节点即可。</li></ul><p><strong>工作方式：</strong></p><p>在redis的每一个节点上，都有这么两个东西，一个是插槽（slot），它的的取值范围是：0-16383。还有一个就是cluster，可以理解为是一个集群管理的插件。当我们的存取的key到达的时候，redis会根据crc16的算法得出一个结果，然后把结果对 16384 求余数，这样每个 key 都会对应一个编号在 0-16383 之间的哈希槽，通过这个值，去找到对应的插槽所对应的节点，然后直接自动跳转到这个对应的节点上进行存取操作。</p><p>为了保证高可用，redis-cluster集群引入了主从模式，一个主节点对应一个或者多个从节点，当主节点宕机的时候，就会启用从节点。当其它主节点ping一个主节点A时，如果半数以上的主节点与A通信超时，那么认为主节点A宕机了。如果主节点A和它的从节点A1都宕机了，那么该集群就无法再提供服务了。</p><h2 id="集群规划"><a href="#集群规划" class="headerlink" title="集群规划"></a>集群规划</h2><p>搭建redis最少需要6个节点。因虚拟机是2台，所以通过配置不同端口的方式，在第一台机器上启动3个节点，第二台上启动3个节点</p><table><thead><tr><th>IP</th><th>端口</th></tr></thead><tbody><tr><td>192.168.31.226</td><td>6379</td></tr><tr><td>192.168.31.226</td><td>6380</td></tr><tr><td>192.168.31.226</td><td>6381</td></tr><tr><td>192.168.31.137</td><td>6379</td></tr><tr><td>192.168.31.137</td><td>6380</td></tr><tr><td>192.168.31.137</td><td>6381</td></tr></tbody></table><h2 id="集群配置"><a href="#集群配置" class="headerlink" title="集群配置"></a>集群配置</h2><p>本文默认认为已经会安装redis，搭建部分不再赘述。需要可参考之前文章<a href="https://guohailan.github.io/2020/06/06/Redis%E4%B8%BB%E4%BB%8E%E5%93%A8%E5%85%B5%E6%90%AD%E5%BB%BA/#%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91%E5%AE%89%E8%A3%85">Redis主从哨兵搭建</a>安装部分</p><p>创建<code>/usr/local/redis/conf_cluster</code>目录，用于存放redis的配置文件。在<code>conf_cluster</code>目录下创建<code>6379</code>、<code>6380</code>、<code>6381</code>目录，修改好的配置文件<code>redis.conf</code>分别放到对应目录下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">port 6379 <span class="comment"># 端口6379 6380 6381</span></span><br><span class="line"><span class="built_in">bind</span> 192.168.31.226 <span class="comment"># 默认ip为127.0.0.1 需要改为其他节点机器可访问的ip 否则创建集群时无法访问对应的端口，无法创建集群</span></span><br><span class="line">daemonize yes <span class="comment"># redis后台运行</span></span><br><span class="line">cluster-enabled yes <span class="comment"># 开启集群</span></span><br><span class="line">pidfile <span class="string">&quot;/usr/local/redis/conf_cluster/6379/redis.pid&quot;</span> <span class="comment"># pidfile文件对应6379 6380 6381</span></span><br><span class="line">appendonly yes <span class="comment"># aof日志开启 有需要就开启，它会每次写操作都记录一条日志</span></span><br><span class="line">dir <span class="string">&quot;/usr/local/redis/conf_cluster&quot;</span> <span class="comment"># 设置redis数据写入目录</span></span><br><span class="line">appendfilename appendonly.aof <span class="comment"># aof日志文件名</span></span><br><span class="line">logfile /tmp/redis-6379.log <span class="comment"># redis日志路径对应6379 6380 6381</span></span><br></pre></td></tr></table></figure><p>启动redis全部节点</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/usr/<span class="built_in">local</span>/redis/bin/redis-server /usr/<span class="built_in">local</span>/redis/conf_cluster/6379/redis.conf</span><br><span class="line">/usr/<span class="built_in">local</span>/redis/bin/redis-server /usr/<span class="built_in">local</span>/redis/conf_cluster/6380/redis.conf</span><br><span class="line">/usr/<span class="built_in">local</span>/redis/bin/redis-server /usr/<span class="built_in">local</span>/redis/conf_cluster/6381/redis.conf</span><br><span class="line">netstat -anp|grep tcp|grep -E <span class="string">&#x27;6379|6380|6381&#x27;</span> <span class="comment">#查看监听端口是否启动</span></span><br></pre></td></tr></table></figure><h2 id="创建集群"><a href="#创建集群" class="headerlink" title="创建集群"></a>创建集群</h2><p>用redis-cli创建整个redis集群(redis5以前的版本集群是依靠ruby脚本redis-trib.rb实现)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/<span class="built_in">local</span>/redis/bin/redis-cli -a 1234 --cluster create --cluster-replicas 1 192.168.31.226:6379 192.168.31.226:6380 192.168.31.226:6381 192.168.31.137:6379 192.168.31.137:6380 192.168.31.137:6381 <span class="comment"># -a 表示使用密码 --cluster-replicas 1表示为每个主节点创建一个副本</span></span><br></pre></td></tr></table></figure><p><img src="/2020/06/18/Redis%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/join.png"></p><p>使用<code>redlis-cli</code>连接任意节点，<code>cluster info</code> 和 <code>cluster nodes</code>可查看当前集群状态，此时集群搭建成功</p><p><img src="/2020/06/18/Redis%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/info.png"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Redis3.0上加入了cluster模式，实现的redis的分布式存储，本文主要介绍Redis集群的相关搭建。&lt;/p&gt;</summary>
    
    
    
    <category term="中间件" scheme="https://guohailan.github.io/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
    <category term="Redis" scheme="https://guohailan.github.io/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/Redis/"/>
    
    
    <category term="搭建文档" scheme="https://guohailan.github.io/tags/%E6%90%AD%E5%BB%BA%E6%96%87%E6%A1%A3/"/>
    
    <category term="Redis" scheme="https://guohailan.github.io/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>使用Jenkins进行持续集成</title>
    <link href="https://guohailan.github.io/2020/06/10/%E4%BD%BF%E7%94%A8Jenkins%E8%BF%9B%E8%A1%8C%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90/"/>
    <id>https://guohailan.github.io/2020/06/10/%E4%BD%BF%E7%94%A8Jenkins%E8%BF%9B%E8%A1%8C%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90/</id>
    <published>2020-06-10T15:15:33.000Z</published>
    <updated>2020-10-20T12:30:40.593Z</updated>
    
    <content type="html"><![CDATA[<p>使用Jenkins进行持续集成，案例在虚拟机上进行搭建，本文主要介绍环境搭建以及配置部分。</p><a id="more"></a><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>机器要求：</p><ul><li>256 MB 内存，建议大于 512 MB</li><li>10 GB 的硬盘空间（用于 Jenkins 和 Docker 镜像）</li></ul><p>需要安装以下软件</p><ul><li>Java 8 ( JRE 或者 JDK 都可以)</li></ul><p>首先从<a href="https://www.jenkins.io/zh/">官网</a>上下载Jenkins安装包，为方便使用这里我直接下载了war包进行安装</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget http://mirrors.jenkins.io/war-stable/latest/jenkins.war</span><br></pre></td></tr></table></figure><p>从国内源下载JDK 8,并且设置JAVA_HOME</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">wget https://repo.huaweicloud.com/java/jdk/8u201-b09/jdk-8u201-linux-x64.tar.gz  <span class="comment"># 下载JDK安装包</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;export JAVA_HOME=/usr/java/jdk1.8.0_201</span></span><br><span class="line"><span class="string">export PATH=$JAVA_HOME/bin:$PATH&#x27;</span> &gt;&gt;/etc/profile  <span class="comment"># 配置java环境变量</span></span><br><span class="line"><span class="built_in">source</span> /etc/profile  <span class="comment"># 使配置的环境变量生效</span></span><br></pre></td></tr></table></figure><p><code>java -version</code>查看java版本,如果出现下图结果，表示JDK安装成功<br><img src="/2020/06/10/%E4%BD%BF%E7%94%A8Jenkins%E8%BF%9B%E8%A1%8C%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90/java_home.png"></p><h2 id="使用Jenkins"><a href="#使用Jenkins" class="headerlink" title="使用Jenkins"></a>使用Jenkins</h2><p>执行<code>java -jar jenkins.war --httpPort=8080</code>启动jenkins，打开浏览器进入链接<code>http://localhost:8080</code>,访问jenkis</p><h3 id="解锁Jenkins"><a href="#解锁Jenkins" class="headerlink" title="解锁Jenkins"></a>解锁Jenkins</h3><p>第一次访问新的Jenkins实例时，系统会要求使用自动生成的密码对其进行解锁。<br><img src="/2020/06/10/%E4%BD%BF%E7%94%A8Jenkins%E8%BF%9B%E8%A1%8C%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90/release.png"><br>从Jenkins控制台日志输出中，复制自动生成的字母数字密码（在两组星号之间）<br><img src="/2020/06/10/%E4%BD%BF%E7%94%A8Jenkins%E8%BF%9B%E8%A1%8C%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90/password.png"></p><h3 id="插件初始化"><a href="#插件初始化" class="headerlink" title="插件初始化"></a>插件初始化</h3><p>在解锁Jenkins页面上，将此密码粘贴到管理员密码字段中，然后单击继续,此时会进入插件安装界面,根据需要进行选择，这里我直接选择了自定义安装，暂时不安装任何插件，因为没有更改源，安装很慢</p><ul><li>安装建议的插件 - 安装推荐的一组插件，这些插件基于最常见的用例.</li><li>选择要安装的插件 - 选择安装的插件集。当你第一次访问插件选择页面时，默认选择建议的插件。</li></ul><p><img src="/2020/06/10/%E4%BD%BF%E7%94%A8Jenkins%E8%BF%9B%E8%A1%8C%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90/plugin.png"><br>插件下载完成后即可进入主页<br><img src="/2020/06/10/%E4%BD%BF%E7%94%A8Jenkins%E8%BF%9B%E8%A1%8C%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90/home_page.png"></p><h3 id="主从搭建"><a href="#主从搭建" class="headerlink" title="主从搭建"></a>主从搭建</h3><p>先点击Manage Jenkins，然后点击Manage Nodes and Clouds<br><img src="/2020/06/10/%E4%BD%BF%E7%94%A8Jenkins%E8%BF%9B%E8%A1%8C%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90/node.png"><br>点击新建节点<br><img src="/2020/06/10/%E4%BD%BF%E7%94%A8Jenkins%E8%BF%9B%E8%A1%8C%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90/slave.png"><br>填写slave相关信息,点击保存<br><img src="/2020/06/10/%E4%BD%BF%E7%94%A8Jenkins%E8%BF%9B%E8%A1%8C%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90/slave_info.png"><br>在Configure Global Security中启用代理Java Web Start Agent Protocol/4 (TLS 加密)配置<br><img src="/2020/06/10/%E4%BD%BF%E7%94%A8Jenkins%E8%BF%9B%E8%A1%8C%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90/agent.png"><br>然后根据提示，将agent.jar拷贝到slave节点目录，然后根据提示的命令运行slave<br><img src="/2020/06/10/%E4%BD%BF%E7%94%A8Jenkins%E8%BF%9B%E8%A1%8C%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90/run_slave.png"><br>此时可以看到slave已经上线<br><img src="/2020/06/10/%E4%BD%BF%E7%94%A8Jenkins%E8%BF%9B%E8%A1%8C%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90/slave1.png"></p><h3 id="用户权限配置"><a href="#用户权限配置" class="headerlink" title="用户权限配置"></a>用户权限配置</h3><p>在一个部门内部，可能存在多个运维人员，而这些运维人员往往负责不同的项目，但是有可能他们用的又是同一个 Jenkins 的不同用户。那么我们就希望实现一个需求，能够不同的用户登录 Jenkins 以后看到不同的项目。由于jenkins默认的权限控制太过简陋，因此我们引入新的插件<code>Role-based Authorization Strategy</code></p><h4 id="插件安装"><a href="#插件安装" class="headerlink" title="插件安装"></a>插件安装</h4><p>首先因国内直连jenkens的插件中心速度很慢，因此先修改源站为清华大学地址<code>https://mirrors.tuna.tsinghua.edu.cn/jenkins/updates/update-center.json</code><br><img src="/2020/06/10/%E4%BD%BF%E7%94%A8Jenkins%E8%BF%9B%E8%A1%8C%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90/qinghua.png"><br>然后搜索插件名进行安装<br><img src="/2020/06/10/%E4%BD%BF%E7%94%A8Jenkins%E8%BF%9B%E8%A1%8C%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90/plugin1.png"></p><h3 id="权限配置"><a href="#权限配置" class="headerlink" title="权限配置"></a>权限配置</h3><p>重启Jenkins以后，再度打开Configure Global Security会发现多了我们刚刚插件的选项，选择Role-Based Strategy，点击保存<br><img src="/2020/06/10/%E4%BD%BF%E7%94%A8Jenkins%E8%BF%9B%E8%A1%8C%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90/role.png"><br>这时在Manage Jenkins就会多出一个选项，Manage and Assign Roles<br><img src="/2020/06/10/%E4%BD%BF%E7%94%A8Jenkins%E8%BF%9B%E8%A1%8C%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90/manage_role.png"><br>在Manage Roles进行角色以及相关权限添加，有Global roles、Item roles以及Node roles可以分别进行配置<br><img src="/2020/06/10/%E4%BD%BF%E7%94%A8Jenkins%E8%BF%9B%E8%A1%8C%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90/global.png"><br>然后点击Assign Roles，进行相关用户的角色授予<br><img src="/2020/06/10/%E4%BD%BF%E7%94%A8Jenkins%E8%BF%9B%E8%A1%8C%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90/assign_roles.png"></p><h3 id="创建JOB"><a href="#创建JOB" class="headerlink" title="创建JOB"></a>创建JOB</h3><p>点击新建job，创建一个Freestyle project的JOB<br><img src="/2020/06/10/%E4%BD%BF%E7%94%A8Jenkins%E8%BF%9B%E8%A1%8C%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90/myjob.png"><br>点击新创建的JOB进行配置，源码管理选择GIT(需要提前安装git插件才会出来这个选项，填入git库地址，以及相关账号及密码)<br><img src="/2020/06/10/%E4%BD%BF%E7%94%A8Jenkins%E8%BF%9B%E8%A1%8C%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90/git.png"><br>定时触发器可根据实际情况进行选择，然后配置构建步骤点击保存即可，我本地是部署nginx静态页面，因此直接执行shell命令进行部署<br><img src="/2020/06/10/%E4%BD%BF%E7%94%A8Jenkins%E8%BF%9B%E8%A1%8C%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90/deploy.png"></p><h3 id="触发构建"><a href="#触发构建" class="headerlink" title="触发构建"></a>触发构建</h3><p>点击立即构建，即可触发构建任务，本次部署为和jenkins同一台机器上的nginx静态页面<br><img src="/2020/06/10/%E4%BD%BF%E7%94%A8Jenkins%E8%BF%9B%E8%A1%8C%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90/build.png"><br>点击控制台输出，可以查看构建过程中的具日志<br><img src="/2020/06/10/%E4%BD%BF%E7%94%A8Jenkins%E8%BF%9B%E8%A1%8C%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90/log.png"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;使用Jenkins进行持续集成，案例在虚拟机上进行搭建，本文主要介绍环境搭建以及配置部分。&lt;/p&gt;</summary>
    
    
    
    <category term="中间件" scheme="https://guohailan.github.io/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
    <category term="Jenkins" scheme="https://guohailan.github.io/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/Jenkins/"/>
    
    
    <category term="搭建文档" scheme="https://guohailan.github.io/tags/%E6%90%AD%E5%BB%BA%E6%96%87%E6%A1%A3/"/>
    
    <category term="jenkins" scheme="https://guohailan.github.io/tags/jenkins/"/>
    
    <category term="持续集成" scheme="https://guohailan.github.io/tags/%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90/"/>
    
  </entry>
  
  <entry>
    <title>calico网络和flannel对比</title>
    <link href="https://guohailan.github.io/2020/06/10/calico%E7%BD%91%E7%BB%9C%E5%92%8Cflannel%E5%AF%B9%E6%AF%94/"/>
    <id>https://guohailan.github.io/2020/06/10/calico%E7%BD%91%E7%BB%9C%E5%92%8Cflannel%E5%AF%B9%E6%AF%94/</id>
    <published>2020-06-10T12:21:08.000Z</published>
    <updated>2020-10-20T12:30:52.537Z</updated>
    
    <content type="html"><![CDATA[<p>本文介绍了k8s常见2中方案的差异，以及各自的优势</p><a id="more"></a><h2 id="Calico"><a href="#Calico" class="headerlink" title="Calico"></a>Calico</h2><h3 id="什么是Calico"><a href="#什么是Calico" class="headerlink" title="什么是Calico"></a>什么是Calico</h3><p>Calico 是一个三层的数据中心网络方案,而且方便集成 OpenStack 这种 IaaS 云架构,能够提供高效可控的 VM、容器、裸机之间的通信。</p><h3 id="Calico网络基本架构"><a href="#Calico网络基本架构" class="headerlink" title="Calico网络基本架构"></a>Calico网络基本架构</h3><p>Calico BGP模式在小规模集群中可以直接互联,在大规模集群中可以通过额外的BGP route reflector来完成。<br><img src="/2020/06/10/calico%E7%BD%91%E7%BB%9C%E5%92%8Cflannel%E5%AF%B9%E6%AF%94/calico.png" alt="Calico"><br>Calico是一个基于BGP的纯三层的网络方案,与OpenStack、Kubernetes、AWS、GCE等云平台都能够良好地集成。Calico在每个计算节点都利用Linux Kernel实现了一个高效的vRouter来负责数据转发。每个vRouter都通过BGP1协议把在本节点上运行的容器的路由信息向整个Calico网络广播,并自动设置到达其他节点的路由转发规则。Calico利用了Linux内核原生的路由和iptables防火墙功能。 进出各个容器、虚拟机和物理主机的所有流量都会在路由到目标之前遍历这些内核规则。</p><h4 id="主要组件"><a href="#主要组件" class="headerlink" title="主要组件"></a>主要组件</h4><ul><li><strong>Felix</strong>：Calico agent,跑在每台需要运行workload的节点上,主要负责配置路由及ACLs等信息来确保endpoint的连通状态；</li><li><strong>etcd</strong>：分布式键值存储,主要负责网络元数据一致性,确保Calico网络状态的准确性；</li><li>**BGPClient(BIRD)**：主要负责把Felix写入kernel的路由信息分发到当前Calico网络,确保workload间的通信的有效性；</li><li>**BGP Route Reflector(BIRD)**：大规模部署时使用,摒弃所有节点互联的mesh模式,通过一个或者多个BGPRoute Reflector来完成集中式的路由分发；</li><li><strong>CalicoCtl</strong>：允许从命令行界面配置实现高级策略和网络。</li></ul><h2 id="Flannel"><a href="#Flannel" class="headerlink" title="Flannel"></a>Flannel</h2><h3 id="什么是Flannel"><a href="#什么是Flannel" class="headerlink" title="什么是Flannel"></a>什么是Flannel</h3><p>Flannel是由CoreOS开发的项目,可能是最直接和最受欢迎的CNI插件。它是容器编排系统中最成熟的网络结构示例之一,旨在实现更好的容器间和主机间网络。随着CNI概念的兴起,Flannel CNI插件算是早期的入门。</p><h3 id="Flannel网络基本架构"><a href="#Flannel网络基本架构" class="headerlink" title="Flannel网络基本架构"></a>Flannel网络基本架构</h3><p><img src="/2020/06/10/calico%E7%BD%91%E7%BB%9C%E5%92%8Cflannel%E5%AF%B9%E6%AF%94/flannel.png" alt="Flannel"><br>Flannel首先创建了一个名为Flannel0的网桥,而且这个网桥的一端连接docker0网桥,另一端连接一个叫作Flanneld的服务进程。Flanneld进程上连etcd,利用etcd来管理可分配的IP地址段资源,同时监控etcd中每个Pod的实际地址,并在内存中建立了一个Pod节点路由表；Flanneld进程下连docker0和物理网络,使用内存中的Pod节点路由表,将docker0发给它的数据包包装起来,利用物理网络的连接将数据包投递到目标Flanneld上,从而完成Pod到Pod之间的直接地址通信。</p><h2 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h2><p>Calico整个过程中始终都是根据iptables规则进行路由转发，并没有进行封包，解包的过程，这和Flannel比起来效率就会快多了。<br>由于Flannel几乎是最早的跨网络通信解决方案，其他的方案都可以被看做是Fannel的某种改进版。  </p><p>Calico的设计比较新颖，Flannel的Host-Gateway模式之所以不能跨二层网络，是因为它只能修改主机的路由，Calico把改路由表的做法换成了标准的BGP路由协议。<br>相当于在每个节点上模拟出一个额外的路由器，由于采用的是标准协议，Calico模拟路由器的路由表信息就可以被传播到网络的其他路由设备中，这样就实现了在三层网络上的高速跨节点网络。<br>不过在现实中的网络并不总是支持BGP路由的，因此Calico也设计了一种IPIP模式，使用Overlay的方式来传输数据。IPIP的包头非常小，而且也是内置在内核中的，因此它的速度理论上比VxLAN快一点点，但安全性更差。</p><h2 id="K8S为什么会出现各种网络方案"><a href="#K8S为什么会出现各种网络方案" class="headerlink" title="K8S为什么会出现各种网络方案"></a>K8S为什么会出现各种网络方案</h2><p><img src="/2020/06/10/calico%E7%BD%91%E7%BB%9C%E5%92%8Cflannel%E5%AF%B9%E6%AF%94/net.png" alt="net1"></p><blockquote><p>由于Docker等容器工具只是利用内核的网络Namespace实现了网络隔离，各个节点上的容器是在所属节点上自动分配IP地址的，从全局来看，这种局部地址就像是不同小区里的门牌号，一旦拿到一个更大的范围上看，就可能是会重复的。  </p></blockquote><p><img src="/2020/06/10/calico%E7%BD%91%E7%BB%9C%E5%92%8Cflannel%E5%AF%B9%E6%AF%94/net2.png" alt="net2"></p><blockquote><p>为了解决这个问题，Flannel设计了一种全局的网络地址分配机制，即使用Etcd来存储网段和节点之间的关系，然后Flannel配置各个节点上的Docker（或其他容器工具），只在分配到当前节点的网段里选择容器IP地址。</p></blockquote><p><img src="/2020/06/10/calico%E7%BD%91%E7%BB%9C%E5%92%8Cflannel%E5%AF%B9%E6%AF%94/net3.png" alt="net3"></p><p><img src="/2020/06/10/calico%E7%BD%91%E7%BB%9C%E5%92%8Cflannel%E5%AF%B9%E6%AF%94/net4.png" alt="net4"></p><p><img src="/2020/06/10/calico%E7%BD%91%E7%BB%9C%E5%92%8Cflannel%E5%AF%B9%E6%AF%94/net5.png" alt="net5"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文介绍了k8s常见2中方案的差异，以及各自的优势&lt;/p&gt;</summary>
    
    
    
    <category term="中间件" scheme="https://guohailan.github.io/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
    <category term="K8S" scheme="https://guohailan.github.io/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/K8S/"/>
    
    
    <category term="k8s" scheme="https://guohailan.github.io/tags/k8s/"/>
    
  </entry>
  
  <entry>
    <title>Redis主从哨兵搭建</title>
    <link href="https://guohailan.github.io/2020/06/06/Redis%E4%B8%BB%E4%BB%8E%E5%93%A8%E5%85%B5%E6%90%AD%E5%BB%BA/"/>
    <id>https://guohailan.github.io/2020/06/06/Redis%E4%B8%BB%E4%BB%8E%E5%93%A8%E5%85%B5%E6%90%AD%E5%BB%BA/</id>
    <published>2020-06-06T07:47:23.000Z</published>
    <updated>2020-10-20T12:31:52.879Z</updated>
    
    <content type="html"><![CDATA[<p>本文章基于最新版本Redis5.0.5版本进行redis主从哨兵模式搭建</p><a id="more"></a><h2 id="Redis-简介"><a href="#Redis-简介" class="headerlink" title="Redis 简介"></a>Redis 简介</h2><p>Redis 是一个开源（BSD许可）的，内存中的数据结构存储系统，它可以用作数据库、缓存和消息中间件. 它支持多种类型的数据结构，如字符串（strings），散列（hashes），列表（lists），集合（sets），有序集合（sorted sets）与范围查询，bitmaps，hyperloglogs 和 地理空间（geospatial）索引半径查询. Redis 内置了复制（replication），LUA脚本（Lua scripting），LRU驱动事件（LRU eviction），事务（transactions）和不同级别的磁盘持久化（persistence），并通过Redis哨兵（Sentinel）和自动分区（Cluster）提供高可用性（high availability）.为了实现其卓越的性能，Redis采用运行在内存中的数据集工作方式.根据您的使用情况，您可以每隔一定时间将数据集导出到磁盘，或者追加到命令日志中. 您也可以关闭持久化功能，将Redis作为一个高效的网络的缓存数据功能使用.</p><h2 id="集群规划"><a href="#集群规划" class="headerlink" title="集群规划"></a>集群规划</h2><p>搭建redis需要1个主节点，且还有2个从节点，所以至少需要配置3个节点。因虚拟机是2台，所以通过配置不同端口的方式，在第一台机器上启动1个主节点，第二台上启动2个从节点，3个节点上分别启动sentinel</p><h2 id="源码编译安装"><a href="#源码编译安装" class="headerlink" title="源码编译安装"></a>源码编译安装</h2><p>首先进入redis<a href="http://www.redis.cn/">官网</a>下载最新版本的redis，源码编译安装,源码安装需要依赖gcc、gcc-c++，如果出现<code>gcc：命令未找到</code>等错误，请先安装对应的依赖</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">wget http://download.redis.io/releases/redis-5.0.5.tar.gz</span><br><span class="line">tar -zvxf redis-5.0.5.tar.gz</span><br><span class="line">make MALLOC=libc <span class="comment">#虚拟机只分配了一核所以未使用-j参数</span></span><br><span class="line">mkdir -p /usr/<span class="built_in">local</span>/redis <span class="comment">#创建redis安装目录</span></span><br><span class="line">make PREFIX=/usr/<span class="built_in">local</span>/redis install</span><br></pre></td></tr></table></figure><p>redis启动的时候会占用一个终端，这是因为没有指定redis.conf文件，启动的时候是按默认进行的。所以如果不想使其占用，我们可以修改 redis.conf 配置文件，修改<code>daemonize no</code> 为 <code>daemonize yes</code>，然后再指定配置文件启动redis服务<br><img src="/2020/06/06/Redis%E4%B8%BB%E4%BB%8E%E5%93%A8%E5%85%B5%E6%90%AD%E5%BB%BA/daemonize.png"><br>然后启动redis进程</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/<span class="built_in">local</span>/redis/bin/redis-server /usr/<span class="built_in">local</span>/redis/conf/redis.conf</span><br></pre></td></tr></table></figure><p>查看端口和使用<code>redis-cli</code>连接redis，启动正常<br><img src="/2020/06/06/Redis%E4%B8%BB%E4%BB%8E%E5%93%A8%E5%85%B5%E6%90%AD%E5%BB%BA/start.png"></p><h2 id="集群配置"><a href="#集群配置" class="headerlink" title="集群配置"></a>集群配置</h2><h3 id="master"><a href="#master" class="headerlink" title="master"></a>master</h3><p>创建<code>/usr/local/redis/conf</code>目录，用于存放redis的配置文件。在<code>conf</code>目录下创建<code>6379</code>目录，修改好的配置文件<code>redis.conf</code>放到目录下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">port 6379 <span class="comment"># 端口6379</span></span><br><span class="line"><span class="built_in">bind</span> 本机ip <span class="comment"># 默认ip为127.0.0.1 需要改为其他节点机器可访问的ip 否则创建集群时无法访问对应的端口，无法创建集群</span></span><br><span class="line">daemonize yes <span class="comment"># redis后台运行</span></span><br><span class="line">pidfile /var/run/redis_6379.pid <span class="comment"># pidfile文件对应6379</span></span><br><span class="line">appendonly yes <span class="comment"># aof日志开启 有需要就开启，它会每次写操作都记录一条日志</span></span><br><span class="line">appendfilename appendonly.aof <span class="comment"># aof日志文件名</span></span><br><span class="line">logfile /tmp/redis-6379.log <span class="comment"># redis日志路径</span></span><br></pre></td></tr></table></figure><p>先kill掉原来验证的单节点进程，然后启动master</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/usr/<span class="built_in">local</span>/redis/bin/redis-server /usr/<span class="built_in">local</span>/redis/conf/6379/redis.conf</span><br><span class="line">netstat -anp|grep tcp|grep -E <span class="string">&#x27;6379&#x27;</span> <span class="comment">#查看监听端口是否启动</span></span><br></pre></td></tr></table></figure><p><img src="/2020/06/06/Redis%E4%B8%BB%E4%BB%8E%E5%93%A8%E5%85%B5%E6%90%AD%E5%BB%BA/cluster_start.png"></p><h3 id="slave"><a href="#slave" class="headerlink" title="slave"></a>slave</h3><p>创建<code>/usr/local/redis/conf</code>目录，用于存放redis的配置文件。在<code>conf</code>目录下创建<code>6379</code>、<code>6380</code>目录，修改好的配置文件<code>redis.conf</code>放到目录下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">port 6379 <span class="comment"># 端口6379、6380</span></span><br><span class="line"><span class="built_in">bind</span> 本机ip <span class="comment"># 默认ip为127.0.0.1 需要改为其他节点机器可访问的ip 否则创建集群时无法访问对应的端口，无法创建集群</span></span><br><span class="line">daemonize yes <span class="comment"># redis后台运行</span></span><br><span class="line">pidfile /var/run/redis_6379.pid <span class="comment"># pidfile文件对应6379、6380</span></span><br><span class="line">appendonly yes <span class="comment"># aof日志开启 有需要就开启，它会每次写操作都记录一条日志</span></span><br><span class="line">appendfilename appendonly.aof <span class="comment"># aof日志文件名</span></span><br><span class="line">logfile /tmp/redis-6379.log <span class="comment"># redis日志路径</span></span><br><span class="line">replicaof 192.168.31.137 6379 <span class="comment">#master节点的ip和端口</span></span><br></pre></td></tr></table></figure><p>然后启动slave</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/usr/<span class="built_in">local</span>/redis/bin/redis-server /usr/<span class="built_in">local</span>/redis/conf/6379/redis.conf</span><br><span class="line">/usr/<span class="built_in">local</span>/redis/bin/redis-server /usr/<span class="built_in">local</span>/redis/conf/6380/redis.conf</span><br></pre></td></tr></table></figure><h3 id="sentinel"><a href="#sentinel" class="headerlink" title="sentinel"></a>sentinel</h3><p>复制安装包中的<code>sentinel.conf</code>文件到redis的配置文件目录下，修改配置文件,将配置文件分别复制到对应的目录</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">port 26379 <span class="comment"># 端口26379、26380</span></span><br><span class="line"><span class="built_in">bind</span> 本机ip <span class="comment"># 默认ip为127.0.0.1 需要改为其他节点机器可访问的ip 否则创建集群时无法访问对应的端口，无法创建集群</span></span><br><span class="line">daemonize yes <span class="comment"># redis后台运行</span></span><br><span class="line">pidfile /var/run/sentinel_26379.pid <span class="comment"># pidfile文件对应6379、6380</span></span><br><span class="line">logfile /tmp/redis-26379.log <span class="comment"># redis日志路径</span></span><br><span class="line">sentinel down-after-milliseconds mymaster 30000 <span class="comment">#master或slave多长时间（默认30秒）不能使用后标记为s_down状态</span></span><br><span class="line">sentinel monitor mymaster 192.168.31.137 6379 2 <span class="comment">#监听的master的集群名和节点，这个后面的数字2,是指当有两个及以上的sentinel服务检测到master宕机，才会去执行主从切换的功能</span></span><br><span class="line">sentinel parallel-syncs mymaster 1 <span class="comment">#指定了在发生failover主备切换时最多可以有多少个slave同时对新的master进行同步，这个数字越小，完成failover所需的时间就越长，但是如果这个数字越大，就意味着越多的slave因为replication而不可用</span></span><br></pre></td></tr></table></figure><p>启动sentinel</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/usr/<span class="built_in">local</span>/redis/bin/redis-sentinel /usr/<span class="built_in">local</span>/redis/conf/6379/sentinel.conf</span><br><span class="line">/usr/<span class="built_in">local</span>/redis/bin/redis-sentinel /usr/<span class="built_in">local</span>/redis/conf/6380/sentinel.conf</span><br></pre></td></tr></table></figure><p>查看sentinel启动状态<br><img src="/2020/06/06/Redis%E4%B8%BB%E4%BB%8E%E5%93%A8%E5%85%B5%E6%90%AD%E5%BB%BA/sentinel.png"></p><h2 id="故障迁移测试"><a href="#故障迁移测试" class="headerlink" title="故障迁移测试"></a>故障迁移测试</h2><p>连接redis集群<code>/usr/local/redis/bin/redis-cli -c -h 192.168.31.226 -p 6379</code>,查询当前master信息，当前集群有2个slave<br><img src="/2020/06/06/Redis%E4%B8%BB%E4%BB%8E%E5%93%A8%E5%85%B5%E6%90%AD%E5%BB%BA/master_info.png"><br>模拟当前master故障，杀掉master进程<br><img src="/2020/06/06/Redis%E4%B8%BB%E4%BB%8E%E5%93%A8%E5%85%B5%E6%90%AD%E5%BB%BA/kill_master.png"><br>再次连接redis集群发现master已经进行了重新选举，选出了新的master<br><img src="/2020/06/06/Redis%E4%B8%BB%E4%BB%8E%E5%93%A8%E5%85%B5%E6%90%AD%E5%BB%BA/master_info2.png"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文章基于最新版本Redis5.0.5版本进行redis主从哨兵模式搭建&lt;/p&gt;</summary>
    
    
    
    <category term="中间件" scheme="https://guohailan.github.io/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
    <category term="Redis" scheme="https://guohailan.github.io/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/Redis/"/>
    
    
    <category term="搭建文档" scheme="https://guohailan.github.io/tags/%E6%90%AD%E5%BB%BA%E6%96%87%E6%A1%A3/"/>
    
    <category term="Redis" scheme="https://guohailan.github.io/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>prometheus+grafana监控搭建</title>
    <link href="https://guohailan.github.io/2020/06/02/prometheus+grafana%E7%9B%91%E6%8E%A7%E6%90%AD%E5%BB%BA/"/>
    <id>https://guohailan.github.io/2020/06/02/prometheus+grafana%E7%9B%91%E6%8E%A7%E6%90%AD%E5%BB%BA/</id>
    <published>2020-06-02T15:26:13.000Z</published>
    <updated>2021-01-17T07:42:15.379Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要介绍prometheus+grafana+consul方案监控系统的搭建，本次搭建采用虚拟机方式进行搭建，采取consul进行服务注册</p><a id="more"></a><h2 id="prometheus安装与配置"><a href="#prometheus安装与配置" class="headerlink" title="prometheus安装与配置"></a>prometheus安装与配置</h2><h3 id="介绍与基本架构"><a href="#介绍与基本架构" class="headerlink" title="介绍与基本架构"></a>介绍与基本架构</h3><p>prometheus是由谷歌研发的一款开源的监控软件，目前已经被云计算本地基金会托管，是继k8s托管的第二个项目。<br><img src="/2020/06/02/prometheus+grafana%E7%9B%91%E6%8E%A7%E6%90%AD%E5%BB%BA/prometheus.png"><br>prometheus根据配置定时去拉取各个节点的数据，默认使用的拉取方式是pull，也可以使用pushgateway提供的push方式获取各个监控节点的数据。将获取到的数据存入TSDB，一款时序型数据库。此时prometheus已经获取到了监控数据，可以使用内置的PromQL进行查询。它的报警功能使用Alertmanager提供，Alertmanager是prometheus的告警管理和发送报警的一个组件。prometheus原生的图标功能过于简单，可将prometheus数据接入grafana，由grafana进行统一管理。</p><h3 id="安装Prometheus-Server"><a href="#安装Prometheus-Server" class="headerlink" title="安装Prometheus Server"></a>安装Prometheus Server</h3><p>首先从官网下载Prometheus安装程序<br><img src="/2020/06/02/prometheus+grafana%E7%9B%91%E6%8E%A7%E6%90%AD%E5%BB%BA/prometheusdownload.png"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://github.com/prometheus/prometheus/releases/download/v2.18.1/prometheus-2.18.1.linux-amd64.tar.gz</span><br></pre></td></tr></table></figure><p>执行执行解压命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -vxf prometheus-2.18.1.linux-amd64.tar.gz</span><br></pre></td></tr></table></figure><p>编辑解压目录下的prometheus.yml，执行命令：<code>vi prometheus.yml</code>进行基本配置</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">[root@guohailan1 prometheus-2.18.1.linux-amd64]<span class="comment"># cat prometheus.yml</span></span><br><span class="line"><span class="comment"># my global config</span></span><br><span class="line">global:</span><br><span class="line">  scrape_interval: 10s <span class="comment">#每10s采集一次数据</span></span><br><span class="line">  evaluation_interval: 10s <span class="comment">#每10s做一次告警检测</span></span><br><span class="line">  scrape_timeout: 5s <span class="comment">#拉取一个 target 的超时时间</span></span><br><span class="line">alerting: <span class="comment">#Alertmanager 相关配置暂时未配置</span></span><br><span class="line">  alertmanagers:</span><br><span class="line">  - static_configs:</span><br><span class="line">    - targets:</span><br><span class="line">rule_files:</span><br><span class="line">scrape_configs:</span><br><span class="line">  - job_name: <span class="string">&#x27;prometheus&#x27;</span></span><br><span class="line">    static_configs:</span><br><span class="line">    - targets: [<span class="string">&#x27;localhost:9090&#x27;</span>]</span><br><span class="line">  - job_name: <span class="string">&#x27;linux-exporter&#x27;</span></span><br><span class="line">    metrics_path: /metrics</span><br><span class="line">    static_configs:</span><br><span class="line">    - targets: [<span class="string">&#x27;192.168.31.48:9100&#x27;</span>]</span><br></pre></td></tr></table></figure><p>配置开机启动，在CentOS8下官方推荐使用systemctl进行开机自启管理</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">cat &lt;&lt; <span class="string">EOF &gt; /usr/lib/systemd/system/prometheus.service</span></span><br><span class="line"><span class="string">[Unit]</span></span><br><span class="line"><span class="string">Description=Prometheus</span></span><br><span class="line"><span class="string">After=network.target</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">[Service]</span></span><br><span class="line"><span class="string">Type=simple</span></span><br><span class="line"><span class="string">ExecStart=/bin/bash -c &quot;/prometheus/prometheus-2.18.1.linux-amd64/prometheus --web.enable-lifecycle --storage.local.retention 24h0m0s --config.file=/prometheus/prometheus-2.18.1.linux-amd64/prometheus.yml&quot;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">[Install]</span></span><br><span class="line"><span class="string">WantedBy=multi-user.target</span></span><br><span class="line"><span class="string">EOF</span></span><br></pre></td></tr></table></figure><p>设置自启动和启动prometheus</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">systemctl <span class="built_in">enable</span> prometheus</span><br><span class="line">systemctl start prometheus</span><br></pre></td></tr></table></figure><p>浏览器端访问<code>http://192.168.31.48:9090/graph</code>，如果出现界面表示搭建成功,如果服务器上有防火墙，可能需要先关闭防火墙或者配置规则<br><img src="/2020/06/02/prometheus+grafana%E7%9B%91%E6%8E%A7%E6%90%AD%E5%BB%BA/9090.png" alt="9090"></p><h2 id="node-exporter安装"><a href="#node-exporter安装" class="headerlink" title="node_exporter安装"></a>node_exporter安装</h2><p>node-exporter用于采集服务器层面的运行指标，包括机器的loadavg、filesystem、meminfo等基础监控，类似于传统主机监控维度的zabbix-agent。node-export由prometheus官方提供、维护，不会捆绑安装，但基本上是必备的exporter。<br><img src="/2020/06/02/prometheus+grafana%E7%9B%91%E6%8E%A7%E6%90%AD%E5%BB%BA/node_exporter.png"><br>从prometheus官网下载相应版本的node_exporter</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://github.com/prometheus/consul_exporter/releases/download/v0.6.0/consul_exporter-0.6.0.linux-amd64.tar.gz</span><br></pre></td></tr></table></figure><p>配置开机启动</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">cat &lt;&lt; <span class="string">EOF &gt; /usr/lib/systemd/system/node_exporter.service</span></span><br><span class="line"><span class="string">[Unit]</span></span><br><span class="line"><span class="string">Description=node_exporter</span></span><br><span class="line"><span class="string">After=network.target </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">[Service]</span></span><br><span class="line"><span class="string">Type=simple</span></span><br><span class="line"><span class="string">ExecStart=/bin/bash -c &quot;/root/exporter/node_exporter-1.0.0-rc.1.linux-amd64/node_exporter&quot;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">[Install]</span></span><br><span class="line"><span class="string">WantedBy=multi-user.target</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">EOF</span></span><br></pre></td></tr></table></figure><h2 id="consul"><a href="#consul" class="headerlink" title="consul"></a>consul</h2><h3 id="安装consul"><a href="#安装consul" class="headerlink" title="安装consul"></a>安装consul</h3><p>Consul 是一个支持多数据中心分布式高可用的服务发现和配置共享的服务软件,由 HashiCorp 公司用 Go 语言开发, 基于 Mozilla Public License 2.0 的协议进行开源. Consul 支持健康检查,并允许 HTTP 和 DNS 协议调用 API 存储键值对.命令行超级好用的虚拟机管理软件 vgrant 也是 HashiCorp 公司开发的产品.一致性协议采用 Raft 算法,用来保证服务的高可用. 使用 GOSSIP 协议管理成员和广播消息, 并且支持 ACL 访问控制.</p><p>首先从官网上下载consul最新版本并且解压</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wget https://releases.hashicorp.com/consul/1.7.3/consul_1.7.3_linux_amd64.zip</span><br><span class="line">unzip consul_1.7.3_linux_amd64.zip</span><br></pre></td></tr></table></figure><p>本案例搭建为单机版本,将下列命令写入start.sh</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">consul agent -data-dir /prometheus/consul/data -<span class="built_in">bind</span>=172.0.0.1 -datacenter=dc1 -ui -client=0.0.0.0 -server -http-port=8500 -bootstrap-expect=1</span><br></pre></td></tr></table></figure><p>配置开机启动</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">cat &lt;&lt; <span class="string">EOF &gt; /usr/lib/systemd/system/consul.service</span></span><br><span class="line"><span class="string">[Unit]</span></span><br><span class="line"><span class="string">Description=consul</span></span><br><span class="line"><span class="string">After=network.target</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">[Service]</span></span><br><span class="line"><span class="string">Type=simple</span></span><br><span class="line"><span class="string">ExecStart=/bin/bash -c &quot;/prometheus/consul/start.sh&quot;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">[Install]</span></span><br><span class="line"><span class="string">WantedBy=multi-user.target</span></span><br><span class="line"><span class="string">EOF</span></span><br></pre></td></tr></table></figure><p>访问<a href="http://localhost:8500/">http://localhost:8500</a> ,能出现界面表示搭建成功<br><img src="/2020/06/02/prometheus+grafana%E7%9B%91%E6%8E%A7%E6%90%AD%E5%BB%BA/consul.png"></p><h3 id="consul注册与删除"><a href="#consul注册与删除" class="headerlink" title="consul注册与删除"></a>consul注册与删除</h3><p>在服务器上使用如下命令将node_exporter,注册成功后可以看到consul界面上出现了注册的信息，Node Checks和Service Checks绿色表示node_exporter状态正常，点击可查看详情</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -X PUT -d <span class="string">&#x27;&#123;&quot;id&quot;: &quot;192.168.31.48&quot;,&quot;name&quot;: &quot;node-exporter&quot;,&quot;address&quot;: &quot;192.168.31.48&quot;,&quot;port&quot;: 9100,&quot;tags&quot;: [&quot;guohailan1&quot;],&quot;checks&quot;: [&#123;&quot;http&quot;: &quot;http://192.168.31.48:9100/metrics&quot;, &quot;interval&quot;: &quot;5s&quot;&#125;]&#125;&#x27;</span>  http://192.168.31.48:8500/v1/agent/service/register</span><br></pre></td></tr></table></figure><p><img src="/2020/06/02/prometheus+grafana%E7%9B%91%E6%8E%A7%E6%90%AD%E5%BB%BA/register.png"><br>如果注册错误或者不使用了可用如下命令删除注册信息</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -X PUT http://192.168.31.48:8500/v1/agent/service/deregister/node-exporter </span><br></pre></td></tr></table></figure><p>###prometheus对接consul<br>修改prometheus配置文件<code>vi /prometheus/prometheus-2.18.1.linux-amd64/prometheus.yml</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># my global config</span></span><br><span class="line">global:</span><br><span class="line">  scrape_interval: 10s</span><br><span class="line">  evaluation_interval: 10s</span><br><span class="line">  scrape_timeout: 5s</span><br><span class="line">alerting:</span><br><span class="line">  alertmanagers:</span><br><span class="line">  - static_configs:</span><br><span class="line">    - targets:</span><br><span class="line">rule_files:</span><br><span class="line">scrape_configs:</span><br><span class="line">  - job_name: <span class="string">&#x27;prometheus&#x27;</span></span><br><span class="line">    static_configs:</span><br><span class="line">    - targets: [<span class="string">&#x27;localhost:9090&#x27;</span>]</span><br><span class="line">  - job_name: <span class="string">&#x27;consul-prometheus&#x27;</span></span><br><span class="line">    consul_sd_configs:</span><br><span class="line">    - server: <span class="string">&#x27;192.168.31.48:8500&#x27;</span> <span class="comment">#consul地址</span></span><br><span class="line">      services: []</span><br><span class="line">    relabel_configs:</span><br><span class="line">    - source_labels: [__meta_consul_service_port] <span class="comment">#prometheus将对匹配上的lables进行操作</span></span><br><span class="line">      regex: 9100</span><br><span class="line">      action: keep</span><br></pre></td></tr></table></figure><p>详细 relabel_configs 配置及说明可以参考 relabel_config 官网说明，这里我简单列举一下里面每个 relabel_action 的作用，方便下边演示。</p><ul><li>replace: 根据 regex 的配置匹配 source_labels 标签的值（注意：多个 source_label 的值会按照 separator 进行拼接），并且将匹配到的值写入到 target_label 当中，如果有多个匹配组，则可以使用 ${1}, ${2} 确定写入的内容。如果没匹配到任何内容则不对 target_label 进行重新， 默认为 replace。</li><li>keep: 丢弃 source_labels 的值中没有匹配到 regex 正则表达式内容的 Target 实例</li><li>drop: 丢弃 source_labels 的值中匹配到 regex 正则表达式内容的 Target 实例</li><li>hashmod: 将 target_label 设置为关联的 source_label 的哈希模块</li><li>labelmap: 根据 regex 去匹配 Target 实例所有标签的名称（注意是名称），并且将捕获到的内容作为为新的标签名称，regex 匹配到标签的的值作为新标签的值</li><li>labeldrop: 对 Target 标签进行过滤，会移除匹配过滤条件的所有标签</li><li>labelkeep: 对 Target 标签进行过滤，会移除不匹配过滤条件的所有标签</li></ul><p>配置完成重启promethus即可看到targets上有新的node_exporter信息，其中Labels中的指标即上一步配置中的 “source_labels”<br><img src="/2020/06/02/prometheus+grafana%E7%9B%91%E6%8E%A7%E6%90%AD%E5%BB%BA/targets.png"></p><h2 id="grafana"><a href="#grafana" class="headerlink" title="grafana"></a>grafana</h2><p>grafana是一个非常酷的数据可视化平台，常常应用于显示监控数据，底层数据源可以支持influxDb、graphite、elasticSeach。  </p><h3 id="安装grafana"><a href="#安装grafana" class="headerlink" title="安装grafana"></a>安装grafana</h3><p>首先还是从<a href="https://grafana.com/grafana/download">官网</a>下载安装包,进行安装</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">wget https://dl.grafana.com/oss/release/grafana-7.0.1-1.x86_64.rpm</span><br><span class="line">sudo yum install grafana-7.0.1-1.x86_64.rpm</span><br><span class="line">systemctl <span class="built_in">enable</span> grafana-server.service <span class="comment">#允许开机启动</span></span><br><span class="line">systemctl start grafana-server.service <span class="comment">#启动grafana</span></span><br></pre></td></tr></table></figure><p>启动服务之后：<a href="http://localhost:3000/">http://localhost:3000</a> 。用户名和密码在初始化都是admin和admin<br><img src="/2020/06/02/prometheus+grafana%E7%9B%91%E6%8E%A7%E6%90%AD%E5%BB%BA/grafana.png"></p><h3 id="配置grafana"><a href="#配置grafana" class="headerlink" title="配置grafana"></a>配置grafana</h3><h4 id="数据源"><a href="#数据源" class="headerlink" title="数据源"></a>数据源</h4><p>首先配置数据源,选择之前搭建的prometheus的连接串，点击保存<br><img src="/2020/06/02/prometheus+grafana%E7%9B%91%E6%8E%A7%E6%90%AD%E5%BB%BA/data_sources.png"></p><h4 id="dashboard"><a href="#dashboard" class="headerlink" title="dashboard"></a>dashboard</h4><p>grafana<a href="https://grafana.com/grafana/dashboards?orderBy=name&direction=asc">官网</a>有很多大神的作品，可以直接使用<br><img src="/2020/06/02/prometheus+grafana%E7%9B%91%E6%8E%A7%E6%90%AD%E5%BB%BA/dashboards.png"><br>grafana支持很多中导入方式，上传json文件或者直接贴json配置，这里因可以使用外网，直接复制模板ID，导入到grafana中<br><img src="/2020/06/02/prometheus+grafana%E7%9B%91%E6%8E%A7%E6%90%AD%E5%BB%BA/import.png"><br>导入完成后，即可看到报表信息<br><img src="/2020/06/02/prometheus+grafana%E7%9B%91%E6%8E%A7%E6%90%AD%E5%BB%BA/view.png"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文主要介绍prometheus+grafana+consul方案监控系统的搭建，本次搭建采用虚拟机方式进行搭建，采取consul进行服务注册&lt;/p&gt;</summary>
    
    
    
    <category term="中间件" scheme="https://guohailan.github.io/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
    <category term="Prometheus" scheme="https://guohailan.github.io/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/Prometheus/"/>
    
    
    <category term="prometheus" scheme="https://guohailan.github.io/tags/prometheus/"/>
    
    <category term="grafana" scheme="https://guohailan.github.io/tags/grafana/"/>
    
    <category term="监控" scheme="https://guohailan.github.io/tags/%E7%9B%91%E6%8E%A7/"/>
    
    <category term="搭建文档" scheme="https://guohailan.github.io/tags/%E6%90%AD%E5%BB%BA%E6%96%87%E6%A1%A3/"/>
    
  </entry>
  
</feed>
